{"version":3,"file":"index.js","sources":["../../../src/dimensions/dimensions.native.js","../../../src/theme/themeEvent.js","../../../src/constants/constants.js","../../../src/dimensions/sizeMap.js","../../../src/context/platform.js","../../../src/dimensions/useDimensions.js","../../../src/constants/ruleHelpers.js","../../../src/theme/restructureTheme.js","../../../src/theme/manageTheme.js","../../../src/helpers/getTheme.js","../../../src/helpers/joinTheme.js","../../../src/theme/buildTheme.js","../../../src/theme/default.js","../../../src/context/reThemeContext.js","../../../src/theme/withTheme.js","../../../src/context/reThemeProvider.js","../../../src/dimensions/dimensions.native.js","../../../src/hooks/useTheme.js","../../../src/hooks/useStylesCallback.js","../../../src/hooks/nativeThemeHook.js"],"sourcesContent":["let RNDimensions\n\nconst loadReactNativeDimensions = () => {\n  const { Dimensions } = require('react-native')\n  return Dimensions\n}\n\nconst checkDimensions = callBack => {\n  return (...props) => {\n    RNDimensions = RNDimensions || loadReactNativeDimensions()\n\n    return RNDimensions\n      ? callBack(...props)\n      : console.error(\n        `[ ReTheme ERROR ] - Missing Dimensions`,\n        `\\n   - You must initialize 'Dimensions' before using the 'ReThemeProvider'`,\n        `\\n   - Do this by calling 'setRNDimensions(Dimensions)'`,\n        `\\n   - The first argument must be the 'Dimensions' export of 'react-native'`,\n        `\\n   - Or an Object with a matching API`\n      )\n  }\n}\n\nexport const setRNDimensions = dims => (RNDimensions = dims)\n\nexport const Dimensions = {\n  get: checkDimensions((...params) => {\n    return RNDimensions ? RNDimensions.get(...params) : { width: 0, height: 0 }\n  }),\n  set: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.set(...params)\n  }),\n  update: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.update(...params)\n  }),\n  addEventListener: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.addEventListener(...params)\n  }),\n  removeEventListener: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.removeEventListener(...params)\n  }),\n}\n","/** @module theme */\n'use strict'\n\nimport { isArr, isFunc, isNum } from '@keg-hub/jsutils'\n\nconst listeners = {}\n\n/**\n * Add a function to an event type\n * <br/> Returns an index which can be used to remove the listener when needed\n * @param {string} event - Names of event to add the listener to\n * @param {function} listener - Listener function to add\n *\n * @returns {number} - Index of the listener in the events array cache\n */\nconst addThemeEvent = (event, listener) => {\n  // Ensure event and listener are passed in correctly\n  if (!event || !isFunc(listener)) return\n\n  // Create the new event event\n  listeners[event] = listeners[event] || []\n\n  // Add the listener to the event event\n  listeners[event].push(listener)\n\n  // Return the index of the added listener\n  return listeners[event].length - 1\n}\n\n/**\n * Remove a registered event listener\n * @param {string} event - Names of event to remove listeners for\n * @param {function} removeListener - Listener function to remove\n *\n * @returns {void}\n */\nconst removeThemeEvent = (event, removeListener) => {\n  // Ensure the proper params are passed in\n  if (!event || !listeners[event] || (!removeListener && removeListener !== 0))\n    return\n\n  // If an index is passed in, use that to remove the listener function\n  isNum(removeListener)\n    ? // Use splice to remove the listener at the correct index\n      listeners[event].splice(removeListener, 1)\n    : // Otherwise ensure the listener and events exists, then filter out the listener\n    isFunc(removeListener) &&\n      isArr(listeners[event]) &&\n      (listeners[event] = listeners[event].filter(\n        listener => listener !== removeListener\n      ))\n}\n\n/**\n * Calls all functions registered to the passed in event name\n * @param {*} event - Event to call listeners for\n * @param {*} params - params to pass to the registered functions\n *\n * @returns {void}\n */\nconst fireThemeEvent = (event, ...params) => {\n  isArr(listeners[event]) &&\n    listeners[event].forEach(listener => listener(...params))\n}\n\n/**\n * Clears registered listeners from the listeners object\n * If event is passed, will only clear listeners for that event\n * @param {string=} event - Name of the event to clear\n *\n * @returns {void}\n */\n// const clearThemeEvents = event => {\n//   event && listeners[event] ? (listeners[event] = []) : (listeners = {})\n// }\n\nexport { addThemeEvent, fireThemeEvent, removeThemeEvent }\n","import { deepFreeze } from '@keg-hub/jsutils'\n\nexport const Constants = deepFreeze({\n  BUILD_EVENT: 'build',\n  CHANGE_EVENT: 'change',\n  RESIZE_EVENT: 'resize',\n  ADD_EVENT: 'addEventListener',\n  REMOVE_EVENT: 'removeEventListener',\n  KEG_STYLES_TAG_ID: `keg-components-stylesheet`,\n  PLATFORM: {\n    NATIVE: '$native',\n    IOS: '$ios',\n    android: '$android',\n    WEB: '$web',\n    ALL: '$all',\n  },\n})\n","/** @module dimensions */\n'use strict'\n\nimport {\n  mapObj,\n  isObj,\n  toNum,\n  isNum,\n  softFalsy,\n  logData,\n} from '@keg-hub/jsutils'\n\n/**\n * Default sizes for a screen width\n * <br/> Can be overwritten with setSizes helper\n * @object\n */\nconst sizeMap = {\n  /**\n   * Name of the breakpoint\n   * Number for each entry defines the breakpoint\n   *  > The Breakpoint is the screen size where the entries becomes active\n   */\n  entries: [\n    [ '$xsmall', 1 ],\n    [ '$small', 320 ],\n    [ '$medium', 768 ],\n    [ '$large', 1024 ],\n    [ '$xlarge', 1366 ],\n  ],\n  hash: {},\n  indexes: {},\n}\n\n/**\n * Builds an index of the entry locations in the sizeMap entries\n * <br/>Builds the key value hash of the entries\n * <br/>Builds the keys array of the entries\n * @function\n *\n * @returns {void}\n */\nconst buildSizeMapParts = () => {\n  sizeMap.indexes = sizeMap.entries.reduce((indexes, entry, index) => {\n    // Add the entry value with the index\n    indexes[entry[0]] = index\n\n    // Add the index with entry value\n    indexes[index] = entry[0]\n\n    // Convert the sizeMap.entries into an object of key value pairs\n    sizeMap.hash[entry[0]] = entry[1]\n\n    return indexes\n  }, {})\n}\n\n/**\n * Updates the sizeMap.entries with custom values\n * <br/>Keys must already exist in the default sizeMap.indexes\n * <br/>Allowed keys are => xsmall | small | medium | large | xlarge\n * @function\n * @param {Object} dims - key value pair of custom sizeMap.entries\n *\n * @returns {Object} - Updated sizeMap object\n */\nexport const setSizes = dims => {\n  if (!isObj(dims))\n    return logData(\n      `setDimensions method requires an argument of type 'Object'.\\nReceived: `,\n      dims,\n      'error'\n    )\n\n  mapObj(dims, (key, value) => {\n    // Get the key index from the sizeMap\n    const keyIndex = sizeMap.indexes[key]\n\n    if (!softFalsy(keyIndex))\n      return logData(\n        `Invalid ${key} for theme size! Allowed keys are xsmall | small | medium | large | xlarge`,\n        'warn'\n      )\n\n    // Convert the value to an integer, just a helper incase value is a string\n    const newSize = toNum(dims[key])\n\n    // Ensure key is a valid key in the sizeMap indexes and the new size is a valid number\n    // Also ensure the entry exists based on the keyIndex\n    //  * This should never happen, but just incase\n    if (!newSize || !sizeMap.entries[keyIndex])\n      return logData(\n        `Invalid size entry. Size must be a number and the size entry must exist!`,\n        `Size: ${newSize}`,\n        `Entry: ${sizeMap.entries[keyIndex]}`,\n        'warn'\n      )\n\n    // Use the keyIndex to find the entry\n    // Set the value to be an entry with key and new size\n    sizeMap.entries[keyIndex] = [ key, newSize ]\n  })\n\n  // Rebuild the sizeMap parts after updating the dimensions\n  buildSizeMapParts()\n\n  return sizeMap\n}\n\n/**\n * Helper to get the a size from the sizeMap based on the passed in width\n * @function\n * @param {string|number} width - number to find the size from\n *\n * @returns\n */\nexport const getSize = width => {\n  // Ensure width is a number that can be compared\n  const checkWidth = (isNum(width) && width) || toNum(width)\n\n  const name = sizeMap.entries.reduce((updateSize, [ key, value ]) => {\n    checkWidth >= value\n      ? // If it is check if there is an updateSize already sent\n        updateSize\n          ? // If an update size exists, then check if it's value is less then value\n            value > sizeMap.hash[updateSize] && (updateSize = key)\n          : // Otherwise just update the size\n            (updateSize = key)\n      : null\n\n    return updateSize\n\n    // Default to xsmall size\n  }, '$xsmall')\n\n  return [ name, sizeMap.hash[name] ]\n}\n\n/**\n * Get an array of all sizes to be merged together\n * @function\n * @param {string} key - Name of the size\n *\n * @returns {Array} - Array of size key names\n */\nexport const getMergeSizes = key => {\n  // Add 1 because slice does not include the last item of the range\n  return sizeMap.entries\n    .slice(0, sizeMap.indexes[key] + 1)\n    .map(([ name, size ]) => name)\n}\n\n// Build the default sizeMap parts\nbuildSizeMapParts()\n\n/**\n * Get the sizeMap object\n * @function\n *\n * @returns {Object} - built sizeMap object\n */\nexport const getSizeMap = () => sizeMap\n","import { isObj } from '@keg-hub/jsutils'\n\nconst webDefPlatform = {\n  OS: 'web',\n  select: obj => isObj(obj) && obj.web,\n  Version: 'ReTheme',\n}\n\nlet RNPlatform\nconst getRNPlatform = () => {\n  return RNPlatform || webDefPlatform\n}\n\nconst setRNPlatform = Plat => {\n  RNPlatform = Plat\n}\n\nexport { setRNPlatform, getRNPlatform }\n","/** @module dimensions */\n'use strict'\n\nimport { useState, useEffect } from 'react'\nimport { Dimensions } from 'ReDimensions'\n\n// Get the original window dimensions\n\nexport const useDimensions = () => {\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n    // Update the state with the updated dimensions data\n    setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listener\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listener\n    return () => {\n      onChange.shouldUnmount = true\n      return Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  // Return the current dimensions\n  return dimensions\n}\n","export const ruleHelpers = {\n\n  // Margin helpers\n  m: `margin`,\n  mT: `marginTop`,\n  mB: `marginBottom`,\n  mR: `marginRight`,\n  mL: `marginLeft`,\n  mH: `marginHorizontal`,\n  mV: `marginVertical`,\n\n  // Padding helpers\n  p: `padding`,\n  pT: `paddingTop`,\n  pB: `paddingBottom`,\n  pR: `paddingRight`,\n  pL: `paddingLeft`,\n  pH: `paddingHorizontal`,\n  pV: `paddingVertical`,\n\n  // Border helpers\n  bC: `borderColor`,\n  bCT: `borderTopColor`,\n  bCB: `borderBottomColor`,\n  bCR: `borderRightColor`,\n  bCL: `borderLeftColor`,\n  bW: `borderWidth`,\n  bS: `borderStyle`,\n  bC: `borderColor`,\n  bRad: `borderRadius`,\n\n  // Color helpers\n  c: `color`,\n  bg: `background`,\n  bgC: `backgroundColor`,\n\n  // Layout helpers\n  d: `display`,\n  ovf: `overflow`,\n  ovfX: `overflowX`,\n  ovfY: `overflowY`,\n  pos: `position`,\n  z: `zIndex`,\n\n  tp: `top`,\n  bt: `bottom`,\n  btm: `bottom`,\n  lt: `left`,\n  rt: `right`,\n\n  // Effect helpers\n  bxS: `boxShadow`,\n  op: `opacity`,\n  ptrE: `pointerEvents`,\n  otl: `outline`,\n\n  // Flex helpers\n  fl: `flex`,\n  flD: `flexDirection`,\n  flWr: `flexWrap`,\n  flB: `flexBasis`,\n  flS: `flexShrink`,\n  jtC: `justifyContent`,\n  alC: `alignContent`,\n  alS: `alignSelf`,\n  alI: `alignItems`,\n  \n  // Dimension helpers\n  w: 'width',\n  h: `height`,\n  minH: `minHeight`,\n  maxH: `maxHeight`,\n  minW: `minWidth`,\n  maxW: `maxWidth`,\n  \n  // Text / Font helpers\n  ftF: `fontFamily`,\n  ftSz: `fontSize`,\n  ftS: `fontStyle`,\n  ftWt: `fontWeight`,\n  lnH: `lineHeight`,\n  ltrS: `letterSpacing`,\n  txAl: `textAlign`,\n  txDc: `textDecoration`,\n\n}","/** @module theme */\n'use strict'\n\nimport { ruleHelpers } from '../constants/ruleHelpers'\nimport { getSizeMap } from '../dimensions'\nimport { Constants } from '../constants'\nimport { getRNPlatform } from '../context/platform'\nimport {\n  isObj,\n  deepMerge,\n  reduceObj,\n  isEmpty,\n  unset,\n  get,\n} from '@keg-hub/jsutils'\n\n// Default platforms to use when restructuring the theme\n// Use array, so we don't lose the order\nconst getDefaultPlatforms = () => {\n  const Platform = getRNPlatform()\n  // Rules for the OS platform ( web || ios || android )\n  const stylePlatforms = ['$' + get(Platform, 'OS')]\n\n  // If it's not a web platform, then add the $native platform\n  if (get(Platform, 'OS') !== 'web') stylePlatforms.push('$native')\n\n  // Rules for all platforms and os's\n  return stylePlatforms.concat([Constants.PLATFORM.ALL])\n}\n\n/**\n * Joins the passed in user platform with the default platforms array\n * @param {Object} usrPlatforms - use defined platforms to use when building the theme\n *\n * @returns {Array} - Contains platforms to use when building the theme\n */\nconst buildPlatforms = usrPlatforms => {\n  const platsToUse = Object.keys(usrPlatforms).filter(key => usrPlatforms[key])\n\n  return getDefaultPlatforms().reduce((platforms, plat) => {\n    usrPlatforms[plat] !== false &&\n      platforms.indexOf(plat) === -1 &&\n      platforms.unshift(plat)\n\n    return platforms\n  }, platsToUse)\n}\n\n/**\n * Searches the theme object for keys that match the passed in size\n * <br/> Maps any found size key objects to the sizedTheme object\n * @function\n * @param {Object} theme - Contains theme style rules\n * @param {Object} sizedTheme - Holds the theme styles for the current size\n * @param {string} size - Current size to search the theme for\n *\n * @returns {Object} theme with the sizes moved to the root level\n */\nconst buildSizedThemes = (theme, sizedTheme, size) => {\n  return reduceObj(\n    theme,\n    (name, value, sizedTheme) => {\n\n      // Check if the name is a shortcut\n      if(ruleHelpers[name]){\n        unset(theme, name)\n        theme[ruleHelpers[name]] = value\n      }\n\n      // If value is not an object, just return the sizedTheme\n      if (!isObj(value)) return sizedTheme\n\n      // If we find the size in the theme, join it with the current sizedTheme\n      if (name === size) {\n        // Merge the current sizedTheme, with the value for this size\n        const mergedSize = deepMerge(sizedTheme, value)\n\n        // Remove the size from the theme\n        // Because it gets moved to the size theme section\n        unset(theme, [size])\n\n        // Return the merged size\n        return mergedSize\n      }\n\n      // Call buildSizedThemes for the values object to look for  sizes in child objects\n      const subSized = buildSizedThemes(value, sizedTheme[name] || {}, size)\n\n      // If the subSized contains keys, then it has size data\n      // So set it to the name for this size\n      if (!isEmpty(subSized)) sizedTheme[name] = subSized\n\n      // Return the updated sized theme\n      return sizedTheme\n    },\n    sizedTheme\n  )\n}\n\n/**\n * Merges styles of any that exist within the platforms object and the theme\n * <br/> If no platforms exists, just return the theme\n * @function\n * @param {Object} theme - Current theme object that holds the style rules\n * @param {boolean} platforms - Platforms to use when building the theme\n *\n * @returns - Merged platform theme rules, or the passed in theme if no rules exist\n */\nconst mergePlatformOS = (theme, platforms) => {\n  const sizeMap = getSizeMap()\n\n  const toMerge = []\n  // Loop the platforms and check if they are allowed and the platform exist on theme\n  // If is a valid platform add to the toMerge array\n  const mergeTheme = Object.keys(theme)\n    .reduce((cleanTheme, key) => {\n      key[0] === '$' && !sizeMap.hash[key]\n        ? platforms.indexOf(key) !== -1 && toMerge.push(theme[key])\n        : (cleanTheme[key] = theme[key])\n\n      return cleanTheme\n    }, {})\n\n  // If any of the platform theme object exist, then merge them together\n  // Otherwise just return the passed in theme object\n  return toMerge.length ? deepMerge(...toMerge) : mergeTheme\n}\n\nconst updatePlatformTheme = (platforms, Platform, themeData) => {\n  // If the themeData is not an object, then just return it\n  // Because we've hit the rules for this tree in the theme\n  if(!isObj(themeData)) return themeData\n\n  // Extract the class && className\n  const { $class, $className, ...cleanTheme } = themeData\n\n  const mergedPlatform = getPlatformTheme(\n    mergePlatformOS(cleanTheme, platforms),\n    platforms,\n    Platform\n  )\n\n  const className = $className || $class\n  className && (mergedPlatform.$class = className)\n\n  return mergedPlatform\n  \n}\n\n/**\n * Traverse through the theme to find any keys matching the current platform\n * <br/> Once a platform key is found, any sub-keys of that object are not searched\n * @function\n * @example:\n * # If platform is web\n * const theme = { font: { web: { size: 12, native: {} }, native: { size: 10 } } }\n * const platformTheme = getPlatformTheme(theme)\n * # returns { font: { size: 12, native: {} }}\n *\n * @param {Object} themes - each theme module, keys are names and values are the theme rules\n * @param {boolean} platforms - Platforms to use when building the theme\n *\n * @returns {Object} - Update theme object with platform keys updated\n */\nconst getPlatformTheme = (theme, platforms, Platform = {}) => {\n  if (!theme) return theme\n\n  return reduceObj(\n    theme,\n    (key, value, platformTheme) => {\n    \n      // Update the current get correct value for the platform key\n      platformTheme[key] = updatePlatformTheme(platforms, Platform, value)\n\n      // Return the update platformTheme object\n      return platformTheme\n\n      // Use the theme as the original platformTheme to return\n    },\n    theme\n  )\n}\n\n/**\n * Traverse through the theme to find any size objects matching this size\n * <br/> Adds them to the root size object, and removes from the default paht\n * @function\n * @example:\n * const meetings = { fontSize: 12, small: { fontSize: 10 } }\n * restructureTheme({ meetings })\n * # returns => { small: { meetings: { fontSize: 10 }, meetings: { fontSize: 12 } }\n *\n * @param {Object} themes - each theme module, keys are names and values are the theme rules\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} - sized theme object with sizes moved to root size object\n */\nexport const restructureTheme = (theme, usrPlatform = {}) => {\n  const Platform = getRNPlatform()\n\n  // Use the theme based on the platform if it exists\n  // Pass in the response after the sizes are set\n  // Loop over the size map hash keys\n  return Object.keys(getSizeMap().hash).reduce((updatedTheme, size) => {\n    // traverse through the theme to find any size objects matching this size\n    const builtSize = buildSizedThemes(theme, theme[size] || {}, size)\n\n    // If builtSize is not empty, then size data was found, so set it to the updatedTheme object\n    if (!isEmpty(builtSize)) updatedTheme[size] = builtSize\n\n    return updatedTheme\n  }, getPlatformTheme(theme, buildPlatforms(usrPlatform), Platform))\n}\n","/**\n * Holds the current theme after it's built\n */\nlet currentTheme = {}\n\n/**\n * Helper to allow other methods to get the current theme used by the provider\n * @returns {Object} currentTheme - Current theme used by the provider\n */\nexport const getCurrentTheme = () => currentTheme\n\n/**\n * Helper to update the current Theme when ever the theme is built\n * Gets added as an event listener, and is called every time the theme is re-built\n * @param {Object} updatedTheme - Update built theme\n */\nexport const updateCurrentTheme = updatedTheme => (currentTheme = updatedTheme)\n","import { deepMerge, get, isArr, isObj, isStr } from '@keg-hub/jsutils'\nimport { getCurrentTheme } from '../theme/manageTheme'\n\n/**\n * Merges the styles from the passed in sources\n * @param {Array} sources - An array of strings, arrays or objects\n *                          If it's a string or array, it searches the theme using get\n *                          If it's a object, it merges it with the other found objects\n *\n * @returns {Object} - built theme styles object\n */\nexport const getTheme = function (...sources) {\n  const theme = getCurrentTheme()\n\n  // Build the styles by merging the sources together\n  // Check if each source is an id to cache or get the styles from the theme\n  return deepMerge(\n    ...sources.reduce((toMerge, source) => {\n      const styles = isObj(source)\n        ? source\n        : isStr(source) || isArr(source)\n          ? get(theme, source)\n          : null\n\n      styles && toMerge.push(styles)\n\n      return toMerge\n    }, [])\n  )\n}\n","import { isArr, isObj, get } from '@keg-hub/jsutils'\nimport { getTheme } from './getTheme'\n\n/**\n * Checks if the passed in arguments match an object array pattern\n * <br/> Which checks is the first argument is a ReTheme object, and the second is an array of paths\n * @param {Object} arg1 - Checks if this is the root ReTheme Object\n *\n * @returns {boolean} - T/F if the passed in arguments match\n */\nconst hasManyFromTheme = arg1 => isObj(arg1) && isObj(arg1.RTMeta)\n\n/**\n * Joins rules from the theme together. Accepts unlimited rules objects\n * <br/> Subset rules can be passed in as an array of key names on the theme to join together\n * <br/> Or the the actual rules objects should be passed in\n * @param {Object} arg1 - Theme, or subset of theme rules\n * @param {Object|Array} arg2 - Subset of theme rules or an array of keys to join from the theme\n * @param {Array} sources - Array of subset theme rules to join together\n *\n * @returns {Object} - Joined theme rules\n */\nexport const joinTheme = (arg1, arg2, ...sources) => {\n\n  process.env.NODE_ENV !== 'production' && console.warn(\n    `[ ReTheme WARN ] - theme.join is deprecated!`,\n    `\\nIt will be removed in an upcoming release.`,\n    `\\nUse theme.get instead!`\n  )\n\n  sources = !isArr(arg2)\n    ? [arg2].concat(sources)\n    : [ ...(arg2.map(arg => (isObj(arg) && arg) || (arg && get(arg1, arg)))), ...sources ]\n\n  return hasManyFromTheme(arg1, arg2)\n    ? getTheme(...sources)\n    : getTheme(arg1, ...sources)\n\n}\n","/** @module theme */\n'use strict'\n\nimport { fireThemeEvent } from './themeEvent'\nimport { Constants } from '../constants'\nimport { getMergeSizes, getSize } from '../dimensions'\nimport { isObj, deepMerge, checkCall } from '@keg-hub/jsutils'\nimport { restructureTheme } from './restructureTheme'\nimport { updateCurrentTheme, getCurrentTheme } from './manageTheme'\nimport { getTheme } from '../helpers/getTheme'\nimport { joinTheme } from '../helpers/joinTheme'\n\n/**\n * Holds the cached merged theme with sizes\n * <br/> Tracks if the theme didn't change, but the size did\n * <br/> Only calls joinThemeSizes instead of restructureTheme\n * @object\n */\nlet themeSizeCache = {}\n\n/**\n * Joins themes from different sizes together based on the index of the sizeKey\n * <br/> It takes the all sizes less then the index of the sizeKey, included in the sizeKey\n * <br/> Then loops over each one and joins them together\n * @function\n * @param {Object} theme - Parent theme object, which holds the child themes organized by their size keys (e.g. $small)\n * @param {string} sizeKey - Name of the current window size\n * @param {Object} [extraTheme={}] - Extra theme items to add to the theme, has lowest priority\n *\n * @returns {Object} - Merged theme\n */\nconst joinThemeSizes = (theme, sizeKey, extraTheme = {}) => {\n  const sizesToMerge = getMergeSizes(sizeKey)\n  return deepMerge(\n    // Add the extra theme first, so it has lowest priority\n    extraTheme,\n    // Get the sizes to merge, and map to the theme\n    ...sizesToMerge.reduce((themes, key) => {\n      // Check if a theme exists for the passed in key\n      // And add it to the themes array\n      theme[key] && themes.push(theme[key])\n\n      return themes\n    }, [])\n  )\n}\n\n/**\n * Checks if the theme is the same as the default theme.\n * <br/> If not then merges the two together.\n * <br /> Also, adds the size themes at the root of the resulting object\n * @function\n * @param {Object} theme - Passed in user there\n * @param {Object} defaultTheme - Cached default theme\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} - Theme object\n */\nconst mergeWithDefault = (theme, defaultTheme, usrPlatform) => {\n  // Check if theres a defaultTheme, and it's not equal to the passed in theme\n  const mergedTheme =\n    defaultTheme && theme !== defaultTheme\n      ? deepMerge(defaultTheme, theme)\n      : deepMerge({}, theme)\n\n  // Build the sizes for the merged theme based on the sizeMap keys\n  return restructureTheme(mergedTheme, usrPlatform)\n}\n\n/**\n * Gets the dimensions of the current screen, and pull the theme if it exists\n * @function\n * @param {Object} theme - Current active theme\n * @param {number} width - Current screen width\n * @param {number} height - Current screen height\n * @param {Object} defaultTheme - Initial theme\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} Subsection of the theme based on current dimensions if it exists\n */\nexport const buildTheme = (theme, width, height, defaultTheme, usrPlatform) => {\n\n  // If theres no theme, or not valid curSize, just return the passed in theme\n  if (!isObj(theme)) return theme\n  if (!isObj(usrPlatform)) usrPlatform = {}\n\n  // Pull out the key and the size that matches the width\n  const [ key, size ] = getSize(width)\n  const RTMeta = { key, size, width, height }\n\n  // Check if the theme has changed since the last time it was built\n  // If not, then short-circuit, and call useCachedTheme with cache data\n  if(themeSizeCache && theme === themeSizeCache.theme)\n    return useCachedTheme(themeSizeCache, RTMeta)\n\n  const mergedTheme = mergeWithDefault(theme, defaultTheme, usrPlatform)\n\n  // Extract the sizes from the theme\n  const {\n    $xsmall,\n    $small,\n    $medium,\n    $large,\n    $xlarge,\n    ...extraTheme\n  } = mergedTheme\n\n  themeSizeCache = { extraTheme, mergedTheme, theme, key }\n\n  return configureBuiltTheme(themeSizeCache, RTMeta)\n}\n\n/**\n * Gets the correct cached theme based on if Viewport size has changed \n * @function\n * @param {Object} themeSizeCache - Cache theme data containing the sizes\n * @param {Object} themeSizeCache.mergedTheme - The full theme with sizes\n * @param {Object} themeSizeCache.extraTheme - The full theme without sizes\n * @param {string} themeSizeCache.key - keg size from the last time the theme was built\n * @param {Object} RTMeta - Meta data about the current state of the theme\n * @param {string} RTMeta.key - Current size key from the size map\n *\n * @returns {Object} Current theme object with the sizes merged\n */\nconst useCachedTheme = (themeSizeCache, RTMeta) => {\n  return RTMeta.key !== themeSizeCache.key\n    ? configureBuiltTheme(themeSizeCache, RTMeta)\n    : checkCall(() => {\n        const currentTheme = getCurrentTheme()\n        fireThemeEvent(Constants.BUILD_EVENT, currentTheme)\n        return currentTheme\n      })\n}\n\n/**\n * Configures the built theme with the correct sizes, helpers and meta data\n * @function\n * @param {Object} themeSizeCache - Cache theme data containing the sizes\n * @param {Object} themeSizeCache.mergedTheme - The full theme with sizes\n * @param {Object} themeSizeCache.extraTheme - The full theme without sizes\n * @param {string} themeSizeCache.key - keg size from the last time the theme was built\n * @param {Object} RTMeta - Meta data about the current state of the theme\n * @param {string} RTMeta.key - Current size key from the size map\n *\n * @returns {Object} Current theme object with the sizes merged\n */\nconst configureBuiltTheme = ({ mergedTheme,  extraTheme }, RTMeta) => {\n\n  // Update the key for the new size\n  // So next compare will use the correct key\n  themeSizeCache.key = RTMeta.key\n\n  const builtTheme = !RTMeta.size\n    ? extraTheme\n    : joinThemeSizes(mergedTheme, RTMeta.key, extraTheme)\n\n  // Add the get and join helpers\n  builtTheme.get = getTheme\n  builtTheme.join = joinTheme\n\n  builtTheme.RTMeta = { ...builtTheme.RTMeta, ...RTMeta }\n\n  updateCurrentTheme(builtTheme)\n\n  fireThemeEvent(Constants.BUILD_EVENT, builtTheme)\n\n  return builtTheme\n}\n","/** @module theme */\n'use strict'\n\nimport { deepMerge, isObj } from '@keg-hub/jsutils'\nimport { Dimensions } from 'ReDimensions'\nimport { buildTheme } from './buildTheme'\n\n/**\n * Holds the default theme which can be set with the setDefaultTheme helper\n */\nlet defaultTheme = {}\n\n/**\n * Overwrites the default them with passed in theme\n * If merge is passed as true, will merge the current default theme with the passed in theme\n * @param {Object} [theme={}] - Theme to overwrite of merge with the default theme\n * @param {boolean} [merge=false] - Should the passed in theme be merged with the default theme\n * @param {boolean} useDimensions - Should subset theme that matches current dimensions\n *\n * @returns {void}\n */\nexport const setDefaultTheme = (theme, merge = false) => {\n  // Ensure the passed in theme is an object\n  if (!isObj(theme))\n    return console.warn(\n      `setDefaultTheme method requires an theme object as the first argument. Received: `,\n      theme\n    )\n\n  // Check if the default theme should be merged, or overwritten\n  defaultTheme = merge ? deepMerge(defaultTheme, theme) : theme\n\n  // Get subset theme that matches current dimensions is useDimensions is true\n  const dims = Dimensions.get('window')\n  const useTheme = buildTheme(defaultTheme, dims.width, dims.height)\n\n  // Return the newly set default theme\n  return useTheme\n}\n\n/**\n * Gets the default theme\n *\n * @returns {Object} - the default theme\n */\nexport const getDefaultTheme = () => defaultTheme\n","/** @module context */\n'use strict'\n\nimport React from 'react'\nimport { getDefaultTheme } from '../theme/default'\n\n/**\n * Creates the initial theme context\n */\nexport const ReThemeContext = React.createContext(getDefaultTheme())\n","/** @module theme */\n'use strict'\n\nimport React from 'react'\nimport { ReThemeContext } from '../context/reThemeContext'\n\n/**\n * Adds the theme, merge and dimensions props from the Context to the passed in components' props\n * @param {*} Component\n *\n * @returns {Class} - React Component wrapping the Context Consumer and the passed in component\n */\nexport const withTheme = Component => {\n  return props => {\n    return (\n      <ReThemeContext.Consumer>\n        { value => {\n          return <Component\n            theme={value}\n            {...props}\n          />\n        } }\n      </ReThemeContext.Consumer>\n    )\n  }\n}\n","/** @module context */\n'use strict'\n\nimport React, { useEffect, useState, useMemo } from 'react'\nimport { ReThemeContext } from './reThemeContext'\nimport { Dimensions } from 'ReDimensions'\nimport { getSize } from '../dimensions/sizeMap'\nimport { buildTheme, getDefaultTheme } from '../theme'\nimport { getCurrentTheme } from '../theme/manageTheme'\nimport { get } from '@keg-hub/jsutils'\n\n/**\n * Context Provider used to set the theme.\n * <br/> All children that use the withTheme function will have access to the passed in theme prop\n * @param {Object} props - Theme provider props\n * @param {Object|Array} props.children - Child components to wrap the with theme provider\n * @param {Object} props.theme - User defined theme\n * @param {boolean} props.merge - Should merge user theme with default theme\n *\n * @returns {Component|Object} - ReThemeContext.Provider - Provides the theme to the Context consumer\n */\nexport const ReThemeProvider = props => {\n  const { children, theme, merge: doMerge, platforms } = props\n  const merge = Boolean(doMerge || (!doMerge && doMerge !== false)) || false\n\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n\n    // Get the size we should change to\n    const changeToSize = getSize(width)\n\n    // If no size to change to, just return\n    if (!changeToSize) return\n\n    // Get the string version of the size to change to\n    const sizeToBe = changeToSize[0]\n\n    // Get the current theme to check the size\n    const currentTheme = getCurrentTheme()\n    // Get the current size string version\n    const currentSize = get(currentTheme, [ 'RTMeta', 'key' ])\n\n    // Check if the sizes are not equal, and if so update the Dimensions with the new size\n    // Update the state with the updated dimensions data\n    sizeToBe !== currentSize &&\n      setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listeners\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listeners\n    return () => {\n      Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  const builtTheme = useMemo(() => {\n    return buildTheme(\n      theme,\n      dimensions.width,\n      dimensions.height,\n      merge && getDefaultTheme(),\n      platforms\n    ) \n  }, [\n    theme,\n    dimensions.width,\n    dimensions.height,\n    merge,\n    platforms,\n  ])\n\n  return (\n    <ReThemeContext.Provider\n      value={builtTheme}\n    >\n      { children }\n    </ReThemeContext.Provider>\n  )\n\n}\n","let RNDimensions\n\nconst loadReactNativeDimensions = () => {\n  const { Dimensions } = require('react-native')\n  return Dimensions\n}\n\nconst checkDimensions = callBack => {\n  return (...props) => {\n    RNDimensions = RNDimensions || loadReactNativeDimensions()\n\n    return RNDimensions\n      ? callBack(...props)\n      : console.error(\n        `[ ReTheme ERROR ] - Missing Dimensions`,\n        `\\n   - You must initialize 'Dimensions' before using the 'ReThemeProvider'`,\n        `\\n   - Do this by calling 'setRNDimensions(Dimensions)'`,\n        `\\n   - The first argument must be the 'Dimensions' export of 'react-native'`,\n        `\\n   - Or an Object with a matching API`\n      )\n  }\n}\n\nexport const setRNDimensions = dims => (RNDimensions = dims)\n\nexport const Dimensions = {\n  get: checkDimensions((...params) => {\n    return RNDimensions ? RNDimensions.get(...params) : { width: 0, height: 0 }\n  }),\n  set: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.set(...params)\n  }),\n  update: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.update(...params)\n  }),\n  addEventListener: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.addEventListener(...params)\n  }),\n  removeEventListener: checkDimensions((...params) => {\n    RNDimensions && RNDimensions.removeEventListener(...params)\n  }),\n}\n","/** @module hooks */\n\nimport { useContext } from 'react'\nimport { ReThemeContext } from '../context/reThemeContext'\n\n/**\n * Uses the useContext hook from react to get the current theme ( Value prop of the context )\n *\n * @returns { Object } - Current theme\n */\nexport const useTheme = () => {\n  return useContext(ReThemeContext)\n}\n","import { useMemo, useCallback } from 'react'\nimport { useTheme } from './useTheme'\nimport { checkCall, isObj, isEmptyColl } from '@keg-hub/jsutils'\n\n/**\n * Create a custom hook for building the styles that are memoized\n * @example\n * const buildStyles = (theme) => {\n *   return {\n *     main: { flexDirection: 'column', ...margin },\n *     button: { main: margin },\n *   }\n * }\n *\n * const styles = useStylesCallback(buildStyles)\n *\n * @param {function} stylesCb - Callback function to build the styles\n * @param {Array} cbDependencies - List of dependencies passed to useCallback hook for the stylesCb\n * @param {Object} [customStyles={}] - Custom styles to pass to the styles callback\n * \n * @returns { Object } - Current theme\n */\nexport const useStylesCallback = (stylesCb, cbDependencies, customStyles) => {\n  // Memorize the passed in callback\n  const cb = useCallback(stylesCb, cbDependencies || [])\n\n  // Ensure the custom styles is real styles object\n  const styles =\n    !customStyles || !isObj(customStyles) || isEmptyColl(customStyles)\n      ? false\n      : customStyles\n\n  // Get the theme object to pass to the styles callback\n  const theme = useTheme()\n\n  // Use the useMemo hook to memoize the call to the stylesCb\n  return useMemo(() => checkCall(cb, theme, styles, ...cbDependencies) || {}, [ theme, cb, styles ])\n}\n","import { useRef, useState, useLayoutEffect } from 'react'\nimport { get, jsonEqual } from '@keg-hub/jsutils'\n\n/**\n * Checks it two passed in objects are equal pointers or equal as json strings\n * @param {Object} obj1 - Object to check\n * @param {Object} obj2 - Object to check\n *\n * @returns {boolean} - If objects are equal\n */\nconst checkEqual = (obj1, obj2) => obj1 === obj2 || jsonEqual(obj1, obj2)\n\n/**\n * Placeholder hook when on native device\n * @param {Object} offValue - When on native, this theme will always be used\n * @param {Object} onValue - Active theme, only used when on web\n * @param {Object} options - Options object that could hold am element ref\n *\n * @returns {Array} - Hook formatted array, same as on web\n */\nexport const nativeThemeHook = (offValue, onValue, options) => {\n  // Get the ref object\n  const hookRef = get(options, 'ref', useRef())\n\n  // Set the default value\n  const [ value, setValue ] = useState(offValue)\n\n  useLayoutEffect(() => {\n    !checkEqual(offValue, value) && setValue(value)\n  }, [ offValue, onValue ])\n\n  // Return an array matching the same format as on web\n  return [ hookRef, offValue, setValue ]\n}\n"],"names":["RNDimensions","loadReactNativeDimensions","require","Dimensions","checkDimensions","callBack","console","error","get","width","height","set","update","addEventListener","removeEventListener","listeners","addThemeEvent","event","listener","isFunc","push","length","removeThemeEvent","removeListener","isNum","splice","isArr","filter","fireThemeEvent","params","forEach","Constants","deepFreeze","BUILD_EVENT","CHANGE_EVENT","RESIZE_EVENT","ADD_EVENT","REMOVE_EVENT","KEG_STYLES_TAG_ID","PLATFORM","NATIVE","IOS","android","WEB","ALL","sizeMap","entries","hash","indexes","buildSizeMapParts","reduce","entry","index","setSizes","dims","isObj","mapObj","key","value","keyIndex","softFalsy","logData","newSize","toNum","getSize","checkWidth","name","updateSize","getMergeSizes","slice","map","RNPlatform","getSizeMap","useDimensions","useState","dimensions","setDimensions","onChange","win","window","scale","fontScale","useEffect","shouldUnmount","ruleHelpers","m","mT","mB","mR","mL","mH","mV","p","pT","pB","pR","pL","pH","pV","bC","bCT","bCB","bCR","bCL","bW","bS","webDefPlatform","OS","select","obj","web","Version","getRNPlatform","setRNPlatform","Plat","buildPlatforms","usrPlatforms","Platform","stylePlatforms","platsToUse","Object","keys","concat","platforms","plat","indexOf","unshift","buildSizedThemes","theme","sizedTheme","size","reduceObj","unset","mergedSize","deepMerge","subSized","isEmpty","updatePlatformTheme","themeData","$class","$className","cleanTheme","mergedPlatform","getPlatformTheme","toMerge","mergeTheme","mergePlatformOS","className","platformTheme","currentTheme","getCurrentTheme","getTheme","sources","source","styles","isStr","hasManyFromTheme","arg1","RTMeta","joinTheme","arg2","arg","themeSizeCache","mergeWithDefault","defaultTheme","usrPlatform","updatedTheme","builtSize","restructureTheme","buildTheme","useCachedTheme","mergedTheme","extraTheme","$xsmall","$small","$medium","$large","$xlarge","configureBuiltTheme","checkCall","builtTheme","sizeKey","sizesToMerge","themes","joinThemeSizes","join","setDefaultTheme","merge","warn","useTheme","getDefaultTheme","ReThemeContext","React","createContext","withTheme","Component","props","Consumer","ReThemeProvider","children","doMerge","Boolean","changeToSize","sizeToBe","useMemo","Provider","setRNDimensions","useContext","useStylesCallback","stylesCb","cbDependencies","customStyles","cb","useCallback","isEmptyColl","nativeThemeHook","offValue","onValue","options","hookRef","useRef","setValue","useLayoutEffect","obj1","obj2","jsonEqual"],"mappings":"yYAAA,IAAIA,EAEEC,0BAA4B,kBACTC,QAAQ,gBAAvBC,YAIJC,gBAAkB,SAAAC,UACf,kBACLL,EAAeA,GAAgBC,6BAG3BI,0BACAC,QAAQC,iTAYHJ,EAAa,CACxBK,IAAKJ,iBAAgB,wBACZJ,KAAeA,GAAaQ,uBAAiB,CAAEC,MAAO,EAAGC,OAAQ,MAE1EC,IAAKP,iBAAgB,iBACnBJ,MAAgBA,GAAaW,0BAE/BC,OAAQR,iBAAgB,iBACtBJ,MAAgBA,GAAaY,6BAE/BC,iBAAkBT,iBAAgB,iBAChCJ,MAAgBA,GAAaa,uCAE/BC,oBAAqBV,iBAAgB,iBACnCJ,MAAgBA,GAAac,s0FClCjC,IAAMC,EAAY,GAUZC,cAAgB,SAACC,EAAOC,MAEvBD,GAAUE,EAAOD,UAGtBH,EAAUE,GAASF,EAAUE,IAAU,GAGvCF,EAAUE,GAAOG,KAAKF,GAGfH,EAAUE,GAAOI,OAAS,GAU7BC,iBAAmB,SAACL,EAAOM,GAE1BN,GAAUF,EAAUE,KAAYM,GAAqC,IAAnBA,KAIvDC,EAAMD,GAEFR,EAAUE,GAAOQ,OAAOF,EAAgB,GAE1CJ,EAAOI,IACLG,EAAMX,EAAUE,MACfF,EAAUE,GAASF,EAAUE,GAAOU,QACnC,SAAAT,UAAYA,IAAaK,QAW3BK,eAAiB,SAACX,8BAAUY,mCAAAA,oBAChCH,EAAMX,EAAUE,KACdF,EAAUE,GAAOa,SAAQ,SAAAZ,UAAYA,eAAYW,OC5DxCE,EAAYC,EAAW,CAClCC,YAAa,QACbC,aAAc,SACdC,aAAc,SACdC,UAAW,mBACXC,aAAc,sBACdC,8CACAC,SAAU,CACRC,OAAQ,UACRC,IAAK,OACLC,QAAS,WACTC,IAAK,OACLC,IAAK,UCGHC,EAAU,CAMdC,QAAS,CACP,CAAE,UAAW,GACb,CAAE,SAAU,KACZ,CAAE,UAAW,KACb,CAAE,SAAU,MACZ,CAAE,UAAW,OAEfC,KAAM,GACNC,QAAS,IAWLC,kBAAoB,WACxBJ,EAAQG,QAAUH,EAAQC,QAAQI,QAAO,SAACF,EAASG,EAAOC,UAExDJ,EAAQG,EAAM,IAAMC,EAGpBJ,EAAQI,GAASD,EAAM,GAGvBN,EAAQE,KAAKI,EAAM,IAAMA,EAAM,GAExBH,IACN,KAYQK,SAAW,SAAAC,UACjBC,EAAMD,IAOXE,EAAOF,GAAM,SAACG,EAAKC,OAEXC,EAAWd,EAAQG,QAAQS,OAE5BG,EAAUD,GACb,OAAOE,oBACMJ,gFACX,YAIEK,EAAUC,EAAMT,EAAKG,QAKtBK,IAAYjB,EAAQC,QAAQa,GAC/B,OAAOE,6FAEIC,oBACCjB,EAAQC,QAAQa,IAC1B,QAKJd,EAAQC,QAAQa,GAAY,CAAEF,EAAKK,MAIrCb,oBAEOJ,GAtCEgB,4EAELP,EACA,UA6COU,QAAU,SAAAvD,OAEfwD,EAAczC,EAAMf,IAAUA,GAAUsD,EAAMtD,GAE9CyD,EAAOrB,EAAQC,QAAQI,QAAO,SAACiB,+BAAcV,OAAKC,cACtDO,GAAcP,IAEVS,EAEIT,EAAQb,EAAQE,KAAKoB,KAAgBA,EAAaV,GAEjDU,EAAaV,GAGfU,IAGN,iBAEI,CAAED,EAAMrB,EAAQE,KAAKmB,KAUjBE,cAAgB,SAAAX,UAEpBZ,EAAQC,QACZuB,MAAM,EAAGxB,EAAQG,QAAQS,GAAO,GAChCa,KAAI,sCAAGJ,mBAAiBA,MAI7BjB,0BCjJIsB,EDyJSC,WAAa,kBAAM3B,GEzJnB4B,cAAgB,gCAIWC,EAASvE,EAAWK,IAAI,cAAtDmE,OAAYC,OAOdC,SAAW,gBAAWC,IAARC,OAEVtE,EAAoCqE,EAApCrE,MAAOC,EAA6BoE,EAA7BpE,OAAQsE,EAAqBF,EAArBE,MAAOC,EAAcH,EAAdG,UAE9BL,EAAc,CAAEnE,MAAAA,EAAOC,OAAAA,EAAQsE,MAAAA,EAAOC,UAAAA,YAMxCC,GAAU,kBAER/E,EAAWU,iBAAiB,SAAUgE,UAG/B,kBACLA,SAASM,eAAgB,EAClBhF,EAAWW,oBAAoB,SAAU+D,aAEjD,IAGIF,GCzCIS,sBAGXC,WACAC,eACAC,kBACAC,iBACAC,gBACAC,sBACAC,oBAGAC,YACAC,gBACAC,mBACAC,kBACAC,iBACAC,uBACAC,qBAGAC,iBACAC,qBACAC,wBACAC,uBACAC,sBACAC,iBACAC,kjCAyCG,0fFlECC,EAAiB,CACrBC,GAAI,MACJC,OAAQ,SAAAC,UAAOtD,EAAMsD,IAAQA,EAAIC,KACjCC,QAAS,WAILC,cAAgB,kBACbzC,GAAcmC,GAGjBO,cAAgB,SAAAC,GACpB3C,EAAa2C,GGsBTC,eAAiB,SAAAC,OAjBfC,EAEAC,EAgBAC,EAAaC,OAAOC,KAAKL,GAAczF,QAAO,SAAA8B,UAAO2D,EAAa3D,aAlBlE4D,EAAWL,gBAEXM,EAAiB,CAAC,IAAM9G,EAAI6G,EAAU,OAGhB,QAAxB7G,EAAI6G,EAAU,OAAiBC,EAAelG,KAAK,WAGhDkG,EAAeI,OAAO,CAAC3F,EAAUQ,SAASK,OAYpBM,QAAO,SAACyE,EAAWC,UACvB,IAAvBR,EAAaQ,KACkB,IAA7BD,EAAUE,QAAQD,IAClBD,EAAUG,QAAQF,GAEbD,IACNJ,IAaCQ,EAAmB,SAAnBA,iBAAoBC,EAAOC,EAAYC,UACpCC,EACLH,GACA,SAAC9D,EAAMR,EAAOuE,MAGT7C,EAAYlB,KACbkE,EAAMJ,EAAO9D,GACb8D,EAAM5C,EAAYlB,IAASR,IAIxBH,EAAMG,GAAQ,OAAOuE,KAGtB/D,IAASgE,EAAM,KAEXG,EAAaC,EAAUL,EAAYvE,UAIzC0E,EAAMJ,EAAO,CAACE,IAGPG,MAIHE,EAAWR,iBAAiBrE,EAAOuE,EAAW/D,IAAS,GAAIgE,UAI5DM,EAAQD,KAAWN,EAAW/D,GAAQqE,GAGpCN,IAETA,IAiCEQ,oBAAsB,SAACd,EAAWN,EAAUqB,OAG5CnF,EAAMmF,GAAY,OAAOA,MAGrBC,EAAsCD,EAAtCC,OAAQC,EAA8BF,EAA9BE,WAAeC,2BAAeH,2BAExCI,EAAiBC,iBA5BD,SAACf,EAAOL,OACxB9E,EAAU2B,aAEVwE,EAAU,GAGVC,EAAazB,OAAOC,KAAKO,GAC5B9E,QAAO,SAAC2F,EAAYpF,SACR,MAAXA,EAAI,IAAeZ,EAAQE,KAAKU,GAE3BoF,EAAWpF,GAAOuE,EAAMvE,IADG,IAA5BkE,EAAUE,QAAQpE,IAAeuF,EAAQ5H,KAAK4G,EAAMvE,IAGjDoF,IACN,WAIEG,EAAQ3H,OAASiH,eAAaU,GAAWC,EAY9CC,CAAgBL,EAAYlB,GAC5BA,EACAN,GAGI8B,EAAYP,GAAcD,SAChCQ,IAAcL,EAAeH,OAASQ,GAE/BL,GAmBHC,iBAAmB,SAACf,EAAOL,OAAWN,yDAAW,UAChDW,EAEEG,EACLH,GACA,SAACvE,EAAKC,EAAO0F,UAGXA,EAAc3F,GAAOgF,oBAAoBd,EAAWN,EAAU3D,GAGvD0F,IAITpB,GAdiBA,GClKjBqB,EAAe,GAMNC,gBAAkB,kBAAMD,GCExBE,SAAW,mBAChBvB,EAAQsB,qCADqBE,2BAAAA,yBAK5BlB,kCACFkB,EAAQtG,QAAO,SAAC8F,EAASS,OACpBC,EAASnG,EAAMkG,GACjBA,EACAE,EAAMF,IAAW/H,EAAM+H,GACrBjJ,EAAIwH,EAAOyB,GACX,YAENC,GAAUV,EAAQ5H,KAAKsI,GAEhBV,IACN,OCjBDY,iBAAmB,SAAAC,UAAQtG,EAAMsG,IAAStG,EAAMsG,EAAKC,SAY9CC,UAAY,SAACF,EAAMG,8BAASR,mCAAAA,2BAQvCA,EAAW9H,EAAMsI,gCAEPA,EAAK1F,KAAI,SAAA2F,UAAQ1G,EAAM0G,IAAQA,GAASA,GAAOzJ,EAAIqJ,EAAMI,0BAAYT,IAD3E,CAACQ,GAAMtC,OAAO8B,GAGXI,iBAAiBC,GACpBN,yCAAYC,IACZD,uBAASM,6BAASL,MClBpBU,EAAiB,GAwCfC,iBAAmB,SAACnC,EAAOoC,EAAcC,UJ2If,SAACrC,OAAOqC,yDAAc,GAC9ChD,EAAWL,uBAKVQ,OAAOC,KAAKjD,aAAazB,MAAMG,QAAO,SAACoH,EAAcpC,OAEpDqC,EAAYxC,EAAiBC,EAAOA,EAAME,IAAS,GAAIA,UAGxDM,EAAQ+B,KAAYD,EAAapC,GAAQqC,GAEvCD,IACNvB,iBAAiBf,EAAOb,eAAekD,GAAchD,IIjJjDmD,CAJDlC,EADJ8B,GAAgBpC,IAAUoC,EACZA,EACA,GADcpC,GAIOqC,IAc1BI,WAAa,SAACzC,EAAOvH,EAAOC,EAAQ0J,EAAcC,OAGxD9G,EAAMyE,GAAQ,OAAOA,EACrBzE,EAAM8G,KAAcA,EAAc,yBAGjBrG,QAAQvD,MAAtBgD,OACFqG,EAAS,CAAErG,IAAAA,EAAKyE,UAAMzH,MAAAA,EAAOC,OAAAA,MAIhCwJ,GAAkBlC,IAAUkC,EAAelC,MAC5C,OAAO0C,eAAeR,EAAgBJ,OAElCa,EAAcR,iBAAiBnC,EAAOoC,EAAcC,GASrDO,GACDD,EANFE,QAMEF,EALFG,OAKEH,EAJFI,QAIEJ,EAHFK,OAGEL,EAFFM,iCAEEN,6DAIGO,oBAFPhB,EAAiB,CAAEU,WAAAA,EAAYD,YAAAA,EAAa3C,MAAAA,EAAOvE,IAAAA,GAERqG,IAevCY,eAAiB,SAACR,EAAgBJ,UAC/BA,EAAOrG,MAAQyG,EAAezG,IACjCyH,oBAAoBhB,EAAgBJ,GACpCqB,GAAU,eACF9B,EAAeC,yBACrB1H,eAAeG,EAAUE,YAAaoH,GAC/BA,MAgBT6B,oBAAsB,WAA+BpB,OAA5Ba,IAAAA,YAAcC,IAAAA,WAI3CV,EAAezG,IAAMqG,EAAOrG,QAEtB2H,EAActB,EAAO5B,KAzHN,SAACF,EAAOqD,OAAST,yDAAa,GAC7CU,EAAelH,cAAciH,UAC5B/C,gBAELsC,6BAEGU,EAAapI,QAAO,SAACqI,EAAQ9H,UAG9BuE,EAAMvE,IAAQ8H,EAAOnK,KAAK4G,EAAMvE,IAEzB8H,IACN,OA+GDC,CAAeb,EAAab,EAAOrG,IAAKmH,GADxCA,SAIJQ,EAAW5K,IAAM+I,SACjB6B,EAAWK,KAAO1B,UAElBqB,EAAWtB,wCAAcsB,EAAWtB,QAAWA,GHhJET,EGkJ9B+B,EAEnBxJ,eAAeG,EAAUE,YAAamJ,GAE/BA,GC5JLhB,EAAe,GAWNsB,gBAAkB,SAAC1D,OAAO2D,8DAEhCpI,EAAMyE,GACT,OAAO1H,QAAQsL,yFAEb5D,GAIJoC,EAAeuB,EAAQrD,EAAU8B,EAAcpC,GAASA,MAGlD1E,EAAOnD,EAAWK,IAAI,UACtBqL,EAAWpB,WAAWL,EAAc9G,EAAK7C,MAAO6C,EAAK5C,eAGpDmL,GAQIC,gBAAkB,kBAAM1B,GCpCxB2B,EAAiBC,EAAMC,cAAcH,mBCGrCI,UAAY,SAAAC,UAChB,SAAAC,UAEHJ,gBAACD,EAAeM,eACZ,SAAA3I,UACOsI,gBAACG,YACNnE,MAAOtE,GACH0I,SCEHE,gBAAkB,SAAAF,OACrBG,EAA+CH,EAA/CG,SAAUvE,EAAqCoE,EAArCpE,MAAcwE,EAAuBJ,EAA9BT,MAAgBhE,EAAcyE,EAAdzE,UACnCgE,EAAQc,QAAQD,IAAaA,IAAuB,IAAZA,KAAuB,mBAK/B9H,EAASvE,EAAWK,IAAI,cAAtDmE,OAAYC,OAOdC,SAAW,gBAAWC,IAARC,OAEVtE,EAAoCqE,EAApCrE,MAAOC,EAA6BoE,EAA7BpE,OAAQsE,EAAqBF,EAArBE,MAAOC,EAAcH,EAAdG,UAGxByH,EAAe1I,QAAQvD,MAGxBiM,OAGCC,EAAWD,EAAa,GAGxBrD,EAAeC,kBAMrBqD,IAJoBnM,EAAI6I,EAAc,CAAE,SAAU,SAKhDzE,EAAc,CAAEnE,MAAAA,EAAOC,OAAAA,EAAQsE,MAAAA,EAAOC,UAAAA,MAM1CC,GAAU,kBAER/E,EAAWU,iBAAiB,SAAUgE,UAG/B,WACL1E,EAAWW,oBAAoB,SAAU+D,aAE1C,QAEGuG,EAAawB,GAAQ,kBAClBnC,WACLzC,EACArD,EAAWlE,MACXkE,EAAWjE,OACXiL,GAASG,kBACTnE,KAED,CACDK,EACArD,EAAWlE,MACXkE,EAAWjE,OACXiL,EACAhE,WAIAqE,gBAACD,EAAec,UACdnJ,MAAO0H,GAELmB,ICrEKO,gBAAkB,SAAAxJ,UAAwBA,GCb1CuI,SAAW,kBACfkB,EAAWhB,ICWPiB,kBAAoB,SAACC,EAAUC,EAAgBC,OAEpDC,EAAKC,EAAYJ,EAAUC,GAAkB,IAG7CxD,KACHyD,IAAiB5J,EAAM4J,IAAiBG,EAAYH,KAEjDA,EAGAnF,EAAQ6D,kBAGPe,GAAQ,kBAAMzB,gBAAUiC,EAAIpF,EAAO0B,6BAAWwD,MAAmB,KAAI,CAAElF,EAAOoF,EAAI1D,KChB9E6D,gBAAkB,SAACC,EAAUC,EAASC,OAE3CC,EAAUnN,EAAIkN,EAAS,MAAOE,sBAGRlJ,EAAS8I,MAA7B9J,OAAOmK,cAEfC,GAAgB,WAjBC,IAACC,EAAMC,GAAND,EAkBJP,MAlBUQ,EAkBAtK,KAlB0BuK,EAAUF,EAAMC,IAkBhCH,EAASnK,KACxC,CAAE8J,EAAUC,IAGR,CAAEE,EAASH,EAAUK"}