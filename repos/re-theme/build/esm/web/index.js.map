{"version":3,"file":"index.js","sources":["../../../src/dimensions/dimensions.js","../../../src/dimensions/useDimensions.js","../../../src/theme/withTheme.js","../../../src/context/reThemeProvider.js","../../../src/hooks/useStylesCallback.js","../../../src/hooks/hookFactory.js","../../../src/hooks/useThemeHover.js","../../../src/hooks/useThemeActive.js","../../../src/hooks/useThemeFocus.js"],"sourcesContent":["export { Dimensions } from './webDimensions'\nexport const setRNDimensions = dims => {}\n\n\n","/** @module dimensions */\n'use strict'\n\nimport { useState, useEffect } from 'react'\nimport { Dimensions } from 'ReDimensions'\n\n// Get the original window dimensions\n\nexport const useDimensions = () => {\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n    // Update the state with the updated dimensions data\n    setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listener\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listener\n    return () => {\n      onChange.shouldUnmount = true\n      return Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  // Return the current dimensions\n  return dimensions\n}\n","/** @module theme */\n'use strict'\n\nimport React from 'react'\nimport { ReThemeContext } from '../context/reThemeContext'\n\n/**\n * Adds the theme, merge and dimensions props from the Context to the passed in components' props\n * @param {*} Component\n *\n * @returns {Class} - React Component wrapping the Context Consumer and the passed in component\n */\nexport const withTheme = Component => {\n  return props => {\n    return (\n      <ReThemeContext.Consumer>\n        { value => {\n          return <Component\n            theme={value}\n            {...props}\n          />\n        } }\n      </ReThemeContext.Consumer>\n    )\n  }\n}\n","/** @module context */\n'use strict'\n\nimport React, { useEffect, useState, useMemo } from 'react'\nimport { ReThemeContext } from './reThemeContext'\nimport { Dimensions } from 'ReDimensions'\nimport { getSize } from '../dimensions/sizeMap'\nimport { buildTheme, getDefaultTheme } from '../theme'\nimport { getCurrentTheme } from '../theme/manageTheme'\nimport { get } from '@keg-hub/jsutils'\n\n/**\n * Context Provider used to set the theme.\n * <br/> All children that use the withTheme function will have access to the passed in theme prop\n * @param {Object} props - Theme provider props\n * @param {Object|Array} props.children - Child components to wrap the with theme provider\n * @param {Object} props.theme - User defined theme\n * @param {boolean} props.merge - Should merge user theme with default theme\n *\n * @returns {Component|Object} - ReThemeContext.Provider - Provides the theme to the Context consumer\n */\nexport const ReThemeProvider = props => {\n  const { children, theme, merge: doMerge, platforms } = props\n  const merge = Boolean(doMerge || (!doMerge && doMerge !== false)) || false\n\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n\n    // Get the size we should change to\n    const changeToSize = getSize(width)\n\n    // If no size to change to, just return\n    if (!changeToSize) return\n\n    // Get the string version of the size to change to\n    const sizeToBe = changeToSize[0]\n\n    // Get the current theme to check the size\n    const currentTheme = getCurrentTheme()\n    // Get the current size string version\n    const currentSize = get(currentTheme, [ 'RTMeta', 'key' ])\n\n    // Check if the sizes are not equal, and if so update the Dimensions with the new size\n    // Update the state with the updated dimensions data\n    sizeToBe !== currentSize &&\n      setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listeners\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listeners\n    return () => {\n      Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  const builtTheme = useMemo(() => {\n    return buildTheme(\n      theme,\n      dimensions.width,\n      dimensions.height,\n      merge && getDefaultTheme(),\n      platforms\n    ) \n  }, [\n    theme,\n    dimensions.width,\n    dimensions.height,\n    merge,\n    platforms,\n  ])\n\n  return (\n    <ReThemeContext.Provider\n      value={builtTheme}\n    >\n      { children }\n    </ReThemeContext.Provider>\n  )\n\n}\n","import { useMemo, useCallback } from 'react'\nimport { useTheme } from './useTheme'\nimport { checkCall, isObj, isEmptyColl } from '@keg-hub/jsutils'\n\n/**\n * Create a custom hook for building the styles that are memoized\n * @example\n * const buildStyles = (theme) => {\n *   return {\n *     main: { flexDirection: 'column', ...margin },\n *     button: { main: margin },\n *   }\n * }\n *\n * const styles = useStylesCallback(buildStyles)\n *\n * @param {function} stylesCb - Callback function to build the styles\n * @param {Array} cbDependencies - List of dependencies passed to useCallback hook for the stylesCb\n * @param {Object} [customStyles={}] - Custom styles to pass to the styles callback\n * \n * @returns { Object } - Current theme\n */\nexport const useStylesCallback = (stylesCb, cbDependencies, customStyles) => {\n  // Memorize the passed in callback\n  const cb = useCallback(stylesCb, cbDependencies || [])\n\n  // Ensure the custom styles is real styles object\n  const styles =\n    !customStyles || !isObj(customStyles) || isEmptyColl(customStyles)\n      ? false\n      : customStyles\n\n  // Get the theme object to pass to the styles callback\n  const theme = useTheme()\n\n  // Use the useMemo hook to memoize the call to the stylesCb\n  return useMemo(() => checkCall(cb, theme, styles, ...cbDependencies) || {}, [ theme, cb, styles ])\n}\n","import { useRef, useState, useCallback, useLayoutEffect } from 'react'\nimport { isFunc, isObj, isColl, deepMerge, checkCall } from '@keg-hub/jsutils'\nimport { Constants } from '../constants'\n\n/**\n * Updates a listener on an element ( add || remove )\n * @param {Object} element - Node to update the event listener on\n * @param {string} type - Type of update to make ( add || remove )\n * @param {Object} events - Events listener names\n * @param {Object} methods - Functions that run when the event is fired\n *\n * @returns {void}\n */\nconst updateListeners = (element, type, events, methods) => {\n  // Just return if no element or event type\n  if (!isObj(element) || !isFunc(element[type])) return null\n\n  // Set the methods to the event\n  element[type](events.on, methods.on)\n  element[type](events.off, methods.off)\n}\n\n/**\n * Works the same as an inline ref function, but adds event listeners to the element\n * <br/> Uses useCallback so that event listeners get changed when the element changes\n * @param {React Ref|Object} ref - React Ref object or regular object\n * @param {Object} events - Events listener names\n * @param {Object} methods - Functions that run when the event is fired\n *\n * @returns {React Callback Ref} - Reference to the callback method\n */\nconst createCBRef = (hookRef, events, methods, ref) => {\n  // This keeps track of the hookRef, and the event listeners on the element\n  return useCallback(\n    element => {\n      // Remove any old events if they exist\n      hookRef.current &&\n        updateListeners(\n          hookRef.current,\n          Constants.REMOVE_EVENT,\n          events,\n          methods\n        )\n\n      // Set the new element to the hookRef.current\n      // Because this hookRef is internal, we have to update current manually\n      hookRef.current = element\n\n      // Add the new listeners to the updated element\n      hookRef.current &&\n        updateListeners(hookRef.current, Constants.ADD_EVENT, events, methods)\n\n      // If no hookRef, then call the clean up method\n      !hookRef.current && methods.cleanup()\n\n      // Want to update the callback when the methods changes\n      // If the values change, then the method will also change\n      // So this will fire when the values change\n    },\n    [ methods.on, methods.off ]\n  )\n}\n\n/**\n * Creates the on and off methods for the hook\n * Wrap them in useCallback so we can use as dependencies in the Main callback ref\n * @param {*} onValue - Value to set when hook is active\n * @param {*} offValue - Value to set when hook is not active\n *\n * @returns {Object} - Contains the hooks to update to values on and off\n */\nconst createMethods = (offValue, onValue, setValue) => {\n  const cbWatchers = [ onValue, offValue ]\n\n  // These methods get called from createCBRef returned function\n  // An event listener is added to the ref.current element\n  // And when the event happens, Then either the on || off method is called!\n  // When called, it calls the setValue function which updates the state with the passed in value\n  return {\n    // Pass in the onValue / offValue to ensure it updates when the value changes\n    // This will also cause the useCallback create from createCBRef to fire\n    off: useCallback(() => setValue(offValue), cbWatchers),\n\n    // Watch both the onValue\n    on: useCallback(() => setValue(onValue), cbWatchers),\n\n    // Clean up helper to avoid memory leaks\n    cleanup: methods => {\n      if (!methods) return\n\n      isFunc(methods.on) && methods.on(undefined)\n      isFunc(methods.off) && methods.off(undefined)\n      onValue = undefined\n      offValue = undefined\n      setValue = undefined\n      methods = undefined\n    },\n  }\n}\n\nconst getOptions = (options = {}) => (options && !isObj(options) ? {} : options)\n\n/**\n * Checks if the onValue and Off value should be joined\n * @param {Object} offValue - Value to use then when state is off\n * @param {Object} onValue - Value to use then when state is on\n * @param {Object} valueOn - Alternate Value to use then when state is on\n * @param {boolean} noMerge - Should merge the onValue with the offValue\n *\n * @returns {Object} - valueOn or merged on / off object\n */\nconst checkJoinValues = (offValue, onValue, valueOn, noMerge) => {\n  // Need to clean it up to be more clear\n  // Just returning deepMerge(offValue, onValue) works the same\n  return noMerge || !isColl(onValue) || !isColl(offValue)\n    ? valueOn\n    : deepMerge(offValue, onValue)\n}\n\n/**\n * Creates a hook that will switch between the passed in values\n * <br/> It switches between values based on the passed in events it's listening to\n * @param {Object} events - Events listener names to listen too\n *\n * @returns {function} - Hook function\n */\nexport const hookFactory = events =>\n  /**\n   * Hook function called from within a react component\n   *\n   * @param {Any} offValue - Value to set when not active\n   * @param {Any} onValue - Value to set when active\n   * @param {boolean} noMerge - Don't merge the offValue with the onValue when false\n   *\n   * @returns {Array} - Contains the ref to be added to an element, and the current value\n   */\n  (offValue, onValue, options = {}) => {\n    const { ref, noMerge } = getOptions(options)\n\n    // Get the ref object\n    const hookRef = ref || useRef()\n    // Set the default value as off\n    const [ value, setValue ] = useState(offValue)\n    const [ valueOn, setValueOn ] = useState(onValue)\n\n    // Set default joinedOnOff, to allow comparing against later\n    const [ activeValue, setActiveValue ] = useState(\n      checkJoinValues(offValue, valueOn, valueOn, noMerge)\n    )\n\n    useLayoutEffect(() => {\n      if (onValue !== valueOn) {\n        setValueOn(onValue)\n        setActiveValue(checkJoinValues(offValue, onValue, onValue, noMerge))\n      }\n    }, [ onValue, valueOn, offValue, noMerge ])\n\n    // Create the callback ref ( i.e. function ref )\n    // Which gets the node the ref is attached to as an argument\n    const elementRef = createCBRef(\n      // Create an internal ref, that keeps track of the current element\n      // This way we can remove event listeners when the element changes\n      hookRef,\n      // Names of events to listen to\n      events,\n      // Create the methods to update the value using the setValue method\n      // These methods call the setValue method, which updates the state\n      createMethods(offValue, activeValue, setValue),\n      ref\n    )\n\n    // Get the value to use based on the current state of the values\n    const useValue =\n      value === offValue\n        ? // If the offValue and value are the same then no updated state\n          value\n        : // Check if value is equal to the activeValue ( original offValue + onValue merged )\n        value === activeValue\n          ? // If value and activeValue are equal,\n          // then the State is active for either the passed in ref or the current ref\n            activeValue\n          : offValue\n\n    return !isFunc(ref)\n      ? // Return the elementRef function and value to the component\n        [ elementRef, useValue, setValue ]\n      : checkCall(() => {\n        // When ref is a function, and there's no change\n        // or when value is not equal to off value or updated value,\n        // then we want to return the off value, because that has the updated state from the\n        // Other refs update\n        // So wrap the callbacks so we can call the passed in ref, and the new ref\n        const wrapRef = element => {\n          ref(element)\n          elementRef(element)\n        }\n\n        return [ wrapRef, useValue, setValue ]\n      })\n  }\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeHover hook based on the 'pointerover' and 'pointerout' events\n */\nexport const useThemeHover = hookFactory({\n  on: 'pointerover',\n  off: 'pointerout',\n})\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeActive hook based on the 'mouseenter' and 'mouseleave' events\n */\nexport const useThemeActive = hookFactory({ on: 'mousedown', off: 'mouseup' })\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeFocus hook based on the 'mouseenter' and 'mouseleave' events\n */\nexport const useThemeFocus = hookFactory({ on: 'focus', off: 'blur' })\n"],"names":["setRNDimensions","dims","useDimensions","useState","Dimensions","get","dimensions","setDimensions","onChange","win","window","width","height","scale","fontScale","useEffect","addEventListener","shouldUnmount","removeEventListener","withTheme","Component","props","React","ReThemeContext","Consumer","value","theme","ReThemeProvider","children","doMerge","merge","platforms","Boolean","changeToSize","getSize","sizeToBe","currentTheme","getCurrentTheme","builtTheme","useMemo","buildTheme","getDefaultTheme","Provider","useStylesCallback","stylesCb","cbDependencies","customStyles","cb","useCallback","styles","isObj","isEmptyColl","useTheme","checkCall","updateListeners","element","type","events","methods","isFunc","on","off","createCBRef","hookRef","ref","current","Constants","REMOVE_EVENT","ADD_EVENT","cleanup","createMethods","offValue","onValue","setValue","cbWatchers","undefined","getOptions","options","checkJoinValues","valueOn","noMerge","isColl","deepMerge","hookFactory","useRef","setValueOn","activeValue","setActiveValue","useLayoutEffect","elementRef","useValue","useThemeHover","useThemeActive","useThemeFocus"],"mappings":"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"}