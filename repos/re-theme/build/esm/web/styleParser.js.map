{"version":3,"file":"styleParser.js","sources":["../../../src/styleParser/getCSSRules.js","../../../src/styleParser/cssToJs.js","../../../src/styleParser/styleSheetParser.js","../../../src/styleParser/validate.js","../../../src/styleParser/addToDom.js"],"sourcesContent":["/**\n * Helper for warnOfError\n * @param {*} error \n * @returns {boolean} true if the input is a DOMException Security Error\n */\nconst isSecurityError = error => {\n  return error instanceof DOMException\n    && error.name?.includes('SecurityError')\n}\n\n/**\n * Helper for getCSSRules - handles the error arising from getting \n * stylesheet cssRules property\n * @param {Object} stylesheet \n * @param {Error} error \n */\nconst warnOfStylesheetError = (stylesheet, error) => {\n  if (isSecurityError(error)) {\n    console.warn(\n      'Cannot parse cross-origin restricted stylesheet from source:',\n      stylesheet?.href,\n      '\\nThis stylesheet will be safely ignored, but if you need access to it, then you should either ensure the domains match or adjust the stylesheet server\\'s security policy.'\n    )\n  }\n  else {\n    console.warn(\n      'Cannot parse stylesheet from source:',\n      stylesheet?.href,\n      `\\n Reason: ${error.name} - ${error.message}`, \n    )\n  }\n}\n\n/**\n * Safely returns the css rules from the stylesheet object,\n * handling any errors that might arise from that and \n * logging them to the console. If an error arose,\n * or if the stylesheet is falsy, this returns an empty array\n * @param {*} stylesheet \n * @return {Array<CSSStyleRule>}\n */\nexport const getCSSRules = stylesheet => {\n  try {\n    return stylesheet\n      ? stylesheet.cssRules\n      : []\n  }\n  catch (e) {\n    warnOfStylesheetError(stylesheet, e)\n  }\n\n  return []\n}","import { exists, camelCase, isArr } from '@keg-hub/jsutils'\n\n\n/**\n * Matches all content between `{}`\n * @example\n * getStyleContent(\".my-class { color: blue }\") === \" color: blue \"\n * @function\n * @param {string} styleStr - Css styles in string format\n * \n * @returns {string} - Content between the {} of the passed in string\n */\nconst getStyleContent = styleStr => {\n  const pattern = /\\{(.+?)\\}/\n  const regex = new RegExp(pattern, 'gi')\n  const matches = []\n  const foundMatch = styleStr.match(regex)\n\n  for (let index in foundMatch){\n    const item = foundMatch[index]\n    matches[index] = item.match(new RegExp(pattern)) \n  }\n\n  return isArr(matches[0]) ? matches[0][1] : ''\n}\n\n/**\n * Converts from css formatted name to js Object format\n * @example\n * cssToJs(\"{ color: blue; font-size: 12px; }\") === { color: 'blue', fontSize: '12px' }\n * @function\n * @param {string} styleStr - Css styles in string format\n * @param {Object} styleObj - Holds the converted styles\n *\n * @returns {Object} - Passed in styleObj, with the styleStr added in object format\n */\nexport const cssToJs = (styleStr, styleObj={}) => {\n  \n  const styles = getStyleContent(styleStr).trim().split(';')\n\n  return styles.reduce((parsed, styleRule) => {\n    if(styleRule.indexOf(':') === -1) return parsed\n\n    let [ name, value ] = styleRule.split(':')\n    name = camelCase(name.trim())\n    value = value.trim()\n\n    return !exists(name) || !exists(value) || name === '' || value === ''\n      ? parsed\n      : { ...parsed, [name]: value }\n\n  }, styleObj)\n\n}\n","import { isArr, checkCall, isObj } from '@keg-hub/jsutils'\nimport { getCSSRules } from './getCSSRules'\nimport { validateArguments } from './validate'\nimport { addToDom } from './addToDom'\nimport { cssToJs } from './cssToJs'\n\n/**\n * Loops a style sheets rules and looks for matching className selectors\n * @function\n * @param {Object} formatted - Object to hold the parsed styles\n * @param {Object} sheet - Dom StyleSheet Object\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {function} callback - Function to call on matching className\n * \n * @returns {Object|string} - CssInJs object or string of the converted styles\n */\nconst loopSheetCssRules = (formatted, sheet, classNames, callback) => {\n  const rules = getCSSRules(sheet)\n\n  // Check the rules of each styleSheet for a matching class\n  return Array.from(rules)\n    .reduce((formatted, cssRule) => {\n\n      if (!cssRule.selectorText || !cssRule.cssText) return formatted\n\n      // Get the rootSelector of the cssRule, any sub-rule definitions will not work\n      // .my-class-name => WORKS\n      // .root-class-name .my-class-name => DOES NOT WORK\n      const rootSelector = cssRule.selectorText.split(' ').shift()\n\n      // Check if the rootSelector is in the classNames\n      // If it is, then call the callback\n      return classNames.includes(rootSelector)\n        ? checkCall(callback, cssRule, rootSelector, formatted, cssToJs)\n        : formatted\n\n    }, formatted)\n}\n\n/**\n * Loops over the styles sheets currently on the DOM\n * <br/>Searches each one for a matching class within the passed in classNames\n * <br/>If it exists, then it converts it to `data-class-name` attribute\n * @function\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {boolean} [toDom=true] - Should the parsed styles be added to the dom\n * \n * @returns {Object|string} - CssInJs object or string of the converted styles\n */\nexport const styleSheetParser = (args) => {\n\n  const {\n    classNames,\n    callback,\n    toDom=true,\n    valid\n  } = validateArguments(args)\n\n  if(valid === false) return {}\n\n  const parsedStyles = isArr(classNames) &&\n    // Have to convert all styleSheets form the DOM into an array to loop over them\n    Array.from(document.styleSheets).reduce(\n      (formatted, sheet) => loopSheetCssRules(formatted, sheet, classNames, callback),\n      { asStr: '' }\n    )\n\n  toDom &&\n    isObj(parsedStyles) &&\n    parsedStyles.asStr &&\n    addToDom(parsedStyles.asStr)\n\n  return parsedStyles\n\n}\n","import { isArr, isFunc } from '@keg-hub/jsutils'\nimport { hasDomAccess } from '../helpers/hasDomAccess'\n\n/**\n * Validates the passed in arguments to ensure styles can be parsed\n * @function\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {boolean} [toDom=true] - Should the parsed styles be added to the dom\n * \n * @returns {Object|boolean} - Passed in args or false if args are invalid\n */\nexport const validateArguments = (args={}) => {\n\n  // Ensure we have dom access and classNames is an array\n  // Otherwise log error an return a string\n  if (!hasDomAccess() || !isArr(args.classNames)){\n    console.error(`[ Error ] styleSheetParser requires Dom Access and an array of class names!`)\n    return { valid: false}\n  }\n\n  // Ensure a callback is passed in\n  if (!isFunc(args.callback)){\n    console.error(`[ Error ] styleSheetParser requires a function callback.\\nIt received:`, args.callback)\n    return { valid: false}\n  }\n\n  return args\n}\n","/**\n * Appends the passed in styles to the DOM\n * @param {string} styles - Style to be added to the dom\n */\nexport const addToDom = styles => {\n\n  const dataCss = document.createElement('style')\n\n  // Based on the browser, we need to set the styles differently\n  dataCss.styleSheet\n    ? (dataCss.styleSheet.cssText = styles)\n    : (dataCss.appendChild(document.createTextNode(styles)))\n\n  // Add the styles to the dom\n  document.getElementsByTagName(\"head\")[0].appendChild(dataCss)\n\n}\n"],"names":["warnOfStylesheetError","stylesheet","error","DOMException","name","_error$name","includes","isSecurityError","console","warn","href","message","getStyleContent","styleStr","pattern","regex","RegExp","matches","foundMatch","match","index","item","isArr","cssToJs","styleObj","styles","trim","split","reduce","parsed","styleRule","indexOf","value","camelCase","exists","loopSheetCssRules","formatted","sheet","classNames","callback","rules","cssRules","e","getCSSRules","Array","from","cssRule","selectorText","cssText","rootSelector","shift","checkCall","styleSheetParser","args","hasDomAccess","isFunc","valid","validateArguments","toDom","dataCss","parsedStyles","document","styleSheets","asStr","isObj","createElement","styleSheet","appendChild","createTextNode","getElementsByTagName"],"mappings":"2LAKA,IAWMA,sBAAwB,SAACC,EAAYC,IAXnB,SAAAA,gBACfA,aAAiBC,yBACnBD,EAAME,yBAANC,EAAYC,SAAS,kBAUtBC,CAAgBL,GAQlBM,QAAQC,KACN,uCACAR,MAAAA,SAAAA,EAAYS,0BACER,EAAME,mBAAUF,EAAMS,UAVtCH,QAAQC,KACN,+DACAR,MAAAA,SAAAA,EAAYS,KACZ,+KCTAE,gBAAkB,SAAAC,OAChBC,EAAU,YACVC,EAAQ,IAAIC,OAAOF,EAAS,MAC5BG,EAAU,GACVC,EAAaL,EAASM,MAAMJ,OAE7B,IAAIK,KAASF,EAAW,KACrBG,EAAOH,EAAWE,GACxBH,EAAQG,GAASC,EAAKF,MAAM,IAAIH,OAAOF,WAGlCQ,EAAML,EAAQ,IAAMA,EAAQ,GAAG,GAAK,IAahCM,QAAU,SAACV,OAAUW,yDAAS,GAEnCC,EAASb,gBAAgBC,GAAUa,OAAOC,MAAM,YAE/CF,EAAOG,QAAO,SAACC,EAAQC,OACG,IAA5BA,EAAUC,QAAQ,KAAa,OAAOF,QAEnBC,EAAUH,MAAM,cAAhCvB,OAAM4B,cACZ5B,EAAO6B,EAAU7B,EAAKsB,QACtBM,EAAQA,EAAMN,OAENQ,EAAO9B,IAAU8B,EAAOF,IAAmB,KAAT5B,GAAyB,KAAV4B,SAEhDH,WAASzB,EAAO4B,IADrBH,IAGHL,ICnCCW,kBAAoB,SAACC,EAAWC,EAAOC,EAAYC,OACjDC,EFwBmB,SAAAvC,cAEhBA,EACHA,EAAWwC,SACX,GAEN,MAAOC,GACL1C,sBAAsBC,EAAYyC,SAG7B,GElCOC,CAAYN,UAGnBO,MAAMC,KAAKL,GACfZ,QAAO,SAACQ,EAAWU,OAEbA,EAAQC,eAAiBD,EAAQE,QAAS,OAAOZ,MAKhDa,EAAeH,EAAQC,aAAapB,MAAM,KAAKuB,eAI9CZ,EAAWhC,SAAS2C,GACvBE,EAAUZ,EAAUO,EAASG,EAAcb,EAAWb,SACtDa,IAEHA,IAaMgB,iBAAmB,SAACC,SCtCA,eAACA,yDAAK,UAIhCC,KAAmBhC,EAAM+B,EAAKf,YAM9BiB,EAAOF,EAAKd,UAKVc,GAJL7C,QAAQN,+EAAgFmD,EAAKd,UACtF,CAAEiB,OAAO,KAPhBhD,QAAQN,qFACD,CAAEsD,OAAO,IDuCdC,CAAkBJ,GAJpBf,IAAAA,WACAC,IAAAA,aACAmB,MAAAA,oBAIW,MAHXF,MAGkB,MAAO,OEtDL/B,EAEhBkC,EFsDAC,EAAetC,EAAMgB,IAEzBM,MAAMC,KAAKgB,SAASC,aAAalC,QAC/B,SAACQ,EAAWC,UAAUF,kBAAkBC,EAAWC,EAAOC,EAAYC,KACtE,CAAEwB,MAAO,YAGbL,GACEM,EAAMJ,IACNA,EAAaG,QEjEOtC,EFkEXmC,EAAaG,OEhElBJ,EAAUE,SAASI,cAAc,UAG/BC,WACHP,EAAQO,WAAWlB,QAAUvB,EAC7BkC,EAAQQ,YAAYN,SAASO,eAAe3C,IAGjDoC,SAASQ,qBAAqB,QAAQ,GAAGF,YAAYR,IF0D9CC"}