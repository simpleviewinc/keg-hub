{"version":3,"file":"index.js","sources":["../../../src/hooks/hookFactory.js","../../../src/hooks/useThemeHover.js","../../../src/hooks/useThemeActive.js","../../../src/hooks/useThemeFocus.js","../../../src/context/reThemeProvider.js","../../../src/dimensions/dimensions.js","../../../src/dimensions/useDimensions.js","../../../src/hooks/useStyle.js","../../../src/hooks/useStylesCallback.js","../../../src/theme/withTheme.js"],"sourcesContent":["import { useRef, useState, useCallback, useLayoutEffect } from 'react'\nimport { isFunc, isObj, isColl, deepMerge, checkCall } from '@keg-hub/jsutils'\nimport { Constants } from '../constants'\n\n/**\n * Updates a listener on an element ( add || remove )\n * @param {Object} element - Node to update the event listener on\n * @param {string} type - Type of update to make ( add || remove )\n * @param {Object} events - Events listener names\n * @param {Object} methods - Functions that run when the event is fired\n *\n * @returns {void}\n */\nconst updateListeners = (element, type, events, methods) => {\n  // Just return if no element or event type\n  if (!isObj(element) || !isFunc(element[type])) return null\n\n  // Set the methods to the event\n  element[type](events.on, methods.on)\n  element[type](events.off, methods.off)\n}\n\n/**\n * Works the same as an inline ref function, but adds event listeners to the element\n * <br/> Uses useCallback so that event listeners get changed when the element changes\n * @param {React Ref|Object} ref - React Ref object or regular object\n * @param {Object} events - Events listener names\n * @param {Object} methods - Functions that run when the event is fired\n *\n * @returns {React Callback Ref} - Reference to the callback method\n */\nconst createCBRef = (hookRef, events, methods, ref) => {\n  // This keeps track of the hookRef, and the event listeners on the element\n  return useCallback(\n    element => {\n      // Remove any old events if they exist\n      hookRef.current &&\n        updateListeners(\n          hookRef.current,\n          Constants.REMOVE_EVENT,\n          events,\n          methods\n        )\n\n      // Set the new element to the hookRef.current\n      // Because this hookRef is internal, we have to update current manually\n      hookRef.current = element\n\n      // Add the new listeners to the updated element\n      hookRef.current &&\n        updateListeners(hookRef.current, Constants.ADD_EVENT, events, methods)\n\n      // If no hookRef, then call the clean up method\n      !hookRef.current && methods.cleanup()\n\n      // Want to update the callback when the methods changes\n      // If the values change, then the method will also change\n      // So this will fire when the values change\n    },\n    [ methods.on, methods.off ]\n  )\n}\n\n/**\n * Creates the on and off methods for the hook\n * Wrap them in useCallback so we can use as dependencies in the Main callback ref\n * @param {*} onValue - Value to set when hook is active\n * @param {*} offValue - Value to set when hook is not active\n *\n * @returns {Object} - Contains the hooks to update to values on and off\n */\nconst createMethods = (offValue, onValue, setValue) => {\n  const cbWatchers = [ onValue, offValue ]\n\n  // These methods get called from createCBRef returned function\n  // An event listener is added to the ref.current element\n  // And when the event happens, Then either the on || off method is called!\n  // When called, it calls the setValue function which updates the state with the passed in value\n  return {\n    // Pass in the onValue / offValue to ensure it updates when the value changes\n    // This will also cause the useCallback create from createCBRef to fire\n    off: useCallback(() => setValue(offValue), cbWatchers),\n\n    // Watch both the onValue\n    on: useCallback(() => setValue(onValue), cbWatchers),\n\n    // Clean up helper to avoid memory leaks\n    cleanup: methods => {\n      if (!methods) return\n\n      isFunc(methods.on) && methods.on(undefined)\n      isFunc(methods.off) && methods.off(undefined)\n      onValue = undefined\n      offValue = undefined\n      setValue = undefined\n      methods = undefined\n    },\n  }\n}\n\nconst getOptions = (options = {}) => (options && !isObj(options) ? {} : options)\n\n/**\n * Checks if the onValue and Off value should be joined\n * @param {Object} offValue - Value to use then when state is off\n * @param {Object} onValue - Value to use then when state is on\n * @param {Object} valueOn - Alternate Value to use then when state is on\n * @param {boolean} noMerge - Should merge the onValue with the offValue\n *\n * @returns {Object} - valueOn or merged on / off object\n */\nconst checkJoinValues = (offValue, onValue, valueOn, noMerge) => {\n  // Need to clean it up to be more clear\n  // Just returning deepMerge(offValue, onValue) works the same\n  return noMerge || !isColl(onValue) || !isColl(offValue)\n    ? valueOn\n    : deepMerge(offValue, onValue)\n}\n\n/**\n * Creates a hook that will switch between the passed in values\n * <br/> It switches between values based on the passed in events it's listening to\n * @param {Object} events - Events listener names to listen too\n *\n * @returns {function} - Hook function\n */\nexport const hookFactory = events =>\n  /**\n   * Hook function called from within a react component\n   *\n   * @param {Any} offValue - Value to set when not active\n   * @param {Any} onValue - Value to set when active\n   * @param {boolean} noMerge - Don't merge the offValue with the onValue when false\n   *\n   * @returns {Array} - Contains the ref to be added to an element, and the current value\n   */\n  (offValue, onValue, options = {}) => {\n    const { ref, noMerge } = getOptions(options)\n\n    // Get the ref object\n    const hookRef = ref || useRef()\n    // Set the default value as off\n    const [ value, setValue ] = useState(offValue)\n    const [ valueOn, setValueOn ] = useState(onValue)\n\n    // Set default joinedOnOff, to allow comparing against later\n    const [ activeValue, setActiveValue ] = useState(\n      checkJoinValues(offValue, valueOn, valueOn, noMerge)\n    )\n\n    useLayoutEffect(() => {\n      if (onValue !== valueOn) {\n        setValueOn(onValue)\n        setActiveValue(checkJoinValues(offValue, onValue, onValue, noMerge))\n      }\n    }, [ onValue, valueOn, offValue, noMerge ])\n\n    // Create the callback ref ( i.e. function ref )\n    // Which gets the node the ref is attached to as an argument\n    const elementRef = createCBRef(\n      // Create an internal ref, that keeps track of the current element\n      // This way we can remove event listeners when the element changes\n      hookRef,\n      // Names of events to listen to\n      events,\n      // Create the methods to update the value using the setValue method\n      // These methods call the setValue method, which updates the state\n      createMethods(offValue, activeValue, setValue),\n      ref\n    )\n\n    // Get the value to use based on the current state of the values\n    const useValue =\n      value === offValue\n        ? // If the offValue and value are the same then no updated state\n          value\n        : // Check if value is equal to the activeValue ( original offValue + onValue merged )\n        value === activeValue\n          ? // If value and activeValue are equal,\n          // then the State is active for either the passed in ref or the current ref\n            activeValue\n          : offValue\n\n    return !isFunc(ref)\n      ? // Return the elementRef function and value to the component\n        [ elementRef, useValue, setValue ]\n      : checkCall(() => {\n        // When ref is a function, and there's no change\n        // or when value is not equal to off value or updated value,\n        // then we want to return the off value, because that has the updated state from the\n        // Other refs update\n        // So wrap the callbacks so we can call the passed in ref, and the new ref\n        const wrapRef = element => {\n          ref(element)\n          elementRef(element)\n        }\n\n        return [ wrapRef, useValue, setValue ]\n      })\n  }\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeHover hook based on the 'pointerover' and 'pointerout' events\n */\nexport const useThemeHover = hookFactory({\n  on: 'pointerover',\n  off: 'pointerout',\n})\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeActive hook based on the 'mouseenter' and 'mouseleave' events\n */\nexport const useThemeActive = hookFactory({ on: 'mousedown', off: 'mouseup' })\n","/** @module hooks */\n\nimport { hookFactory } from './hookFactory'\n\n/**\n * Creates an useThemeFocus hook based on the 'mouseenter' and 'mouseleave' events\n */\nexport const useThemeFocus = hookFactory({ on: 'focus', off: 'blur' })\n","/** @module context */\n'use strict'\n\nimport React, { useEffect, useState, useMemo } from 'react'\nimport { ReThemeContext } from './reThemeContext'\nimport { Dimensions } from 'ReDimensions'\nimport { getSize } from '../dimensions/sizeMap'\nimport { buildTheme, getDefaultTheme } from '../theme'\nimport { getCurrentTheme } from '../theme/manageTheme'\nimport { get } from '@keg-hub/jsutils'\n\n/**\n * Context Provider used to set the theme.\n * <br/> All children that use the withTheme function will have access to the passed in theme prop\n * @param {Object} props - Theme provider props\n * @param {Object|Array} props.children - Child components to wrap the with theme provider\n * @param {Object} props.theme - User defined theme\n * @param {boolean} props.merge - Should merge user theme with default theme\n *\n * @returns {Component|Object} - ReThemeContext.Provider - Provides the theme to the Context consumer\n */\nexport const ReThemeProvider = props => {\n  const { children, theme, merge: doMerge, platforms } = props\n  const merge = Boolean(doMerge || (!doMerge && doMerge !== false)) || false\n\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n\n    // Get the size we should change to\n    const changeToSize = getSize(width)\n\n    // If no size to change to, just return\n    if (!changeToSize) return\n\n    // Get the string version of the size to change to\n    const sizeToBe = changeToSize[0]\n\n    // Get the current theme to check the size\n    const currentTheme = getCurrentTheme()\n    // Get the current size string version\n    const currentSize = get(currentTheme, [ 'RTMeta', 'key' ])\n\n    // Check if the sizes are not equal, and if so update the Dimensions with the new size\n    // Update the state with the updated dimensions data\n    sizeToBe !== currentSize &&\n      setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listeners\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listeners\n    return () => {\n      Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  const builtTheme = useMemo(() => {\n    return buildTheme(\n      theme,\n      dimensions.width,\n      dimensions.height,\n      merge && getDefaultTheme(),\n      platforms\n    ) \n  }, [\n    theme,\n    dimensions.width,\n    dimensions.height,\n    merge,\n    platforms,\n  ])\n\n  return (\n    <ReThemeContext.Provider\n      value={builtTheme}\n    >\n      { children }\n    </ReThemeContext.Provider>\n  )\n\n}\n","export { Dimensions } from './webDimensions'\nexport const setRNDimensions = dims => {}\n\n\n","/** @module dimensions */\n'use strict'\n\nimport { useState, useEffect } from 'react'\nimport { Dimensions } from 'ReDimensions'\n\n// Get the original window dimensions\n\nexport const useDimensions = () => {\n  /**\n   * Set the original dimensions to the state hook\n   */\n  const [ dimensions, setDimensions ] = useState(Dimensions.get('window'))\n\n  /**\n   * onChange listener for when the screen size changes\n   *\n   * @param {Object} arguments.window - holds the size of the current window\n   */\n  const onChange = ({ window: win }) => {\n    // Pull out the relevant items form the window object\n    const { width, height, scale, fontScale } = win\n    // Update the state with the updated dimensions data\n    setDimensions({ width, height, scale, fontScale })\n  }\n\n  /**\n   * Use the useEffect hook to set the Dimensions event listeners\n   */\n  useEffect(() => {\n    // Add the event listener\n    Dimensions.addEventListener('change', onChange)\n\n    // Return a function to remove the event listener\n    return () => {\n      onChange.shouldUnmount = true\n      return Dimensions.removeEventListener('change', onChange)\n    }\n  }, [])\n\n  // Return the current dimensions\n  return dimensions\n}\n","/** @module hooks */\n\nimport { useMemo } from 'react'\nimport { useTheme } from './useTheme'\nimport { noPropObj } from '@keg-hub/jsutils'\n\n/**\n * Merges styles defined by styleArgs into a memoized style object\n * @param  {...(string | Object)} styleArgs - any number of strings or style objects. Strings are expected to be theme paths, which will be used to get the associated theme object for that path.\n * @returns {Object} - result of merging style objects\n * @example\n * const textStyles = useStyle('todos.text', textStylesObject)\n * const myStyles = useStyle(\n *  'settings.button',\n *  { main: { margin: 5 }},\n *  inputStyles,\n *  'someOtherPath.button'\n * )\n */\nexport const useStyle = (...styleArgs) => {\n  const theme = useTheme()\n  return useMemo(() => theme.get(...styleArgs) || noPropObj, [\n    theme,\n    ...styleArgs,\n  ])\n}\n","import { useMemo, useCallback } from 'react'\nimport { useTheme } from './useTheme'\nimport { checkCall, isObj, isEmptyColl } from '@keg-hub/jsutils'\n\n/**\n * Create a custom hook for building the styles that are memoized\n * @example\n * const buildStyles = (theme) => {\n *   return {\n *     main: { flexDirection: 'column', ...margin },\n *     button: { main: margin },\n *   }\n * }\n *\n * const styles = useStylesCallback(buildStyles)\n *\n * @param {function} stylesCb - Callback function to build the styles\n * @param {Array} cbDependencies - List of dependencies passed to useCallback hook for the stylesCb\n * @param {Object} [customStyles={}] - Custom styles to pass to the styles callback\n * \n * @returns { Object } - Current theme\n */\nexport const useStylesCallback = (stylesCb, cbDependencies, customStyles) => {\n  // Memorize the passed in callback\n  const cb = useCallback(stylesCb, cbDependencies || [])\n\n  // Ensure the custom styles is real styles object\n  const styles =\n    !customStyles || !isObj(customStyles) || isEmptyColl(customStyles)\n      ? false\n      : customStyles\n\n  // Get the theme object to pass to the styles callback\n  const theme = useTheme()\n\n  // Use the useMemo hook to memoize the call to the stylesCb\n  return useMemo(() => checkCall(cb, theme, styles, ...cbDependencies) || {}, [ theme, cb, styles ])\n}\n","/** @module theme */\n'use strict'\n\nimport React from 'react'\nimport { ReThemeContext } from '../context/reThemeContext'\n\n/**\n * Adds the theme, merge and dimensions props from the Context to the passed in components' props\n * @param {*} Component\n *\n * @returns {Class} - React Component wrapping the Context Consumer and the passed in component\n */\nexport const withTheme = Component => {\n  return props => {\n    return (\n      <ReThemeContext.Consumer>\n        { value => {\n          return <Component\n            theme={value}\n            {...props}\n          />\n        } }\n      </ReThemeContext.Consumer>\n    )\n  }\n}\n"],"names":["updateListeners","element","type","events","methods","isObj","isFunc","on","off","createCBRef","hookRef","ref","useCallback","current","Constants","REMOVE_EVENT","ADD_EVENT","cleanup","createMethods","offValue","onValue","setValue","cbWatchers","undefined","getOptions","options","checkJoinValues","valueOn","noMerge","isColl","deepMerge","hookFactory","useRef","useState","value","setValueOn","activeValue","setActiveValue","useLayoutEffect","elementRef","useValue","checkCall","useThemeHover","useThemeActive","useThemeFocus","props","children","theme","doMerge","merge","platforms","Boolean","Dimensions","get","dimensions","setDimensions","onChange","win","window","width","height","scale","fontScale","changeToSize","getSize","sizeToBe","currentTheme","getCurrentTheme","useEffect","addEventListener","removeEventListener","builtTheme","useMemo","buildTheme","getDefaultTheme","React","ReThemeContext","Provider","dims","shouldUnmount","styleArgs","useTheme","noPropObj","stylesCb","cbDependencies","customStyles","cb","styles","isEmptyColl","Component","Consumer"],"mappings":"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"}