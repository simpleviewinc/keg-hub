{"version":3,"file":"styleParser.js","sources":["../../../src/styleParser/cssToJs.js","../../../src/styleParser/styleSheetParser.js","../../../src/styleParser/validate.js","../../../src/styleParser/addToDom.js"],"sourcesContent":["import { exists, camelCase, isArr } from '@keg-hub/jsutils'\n\n/**\n * Matches all content between `{}`\n * @example\n * getStyleContent(\".my-class { color: blue }\") === \" color: blue \"\n * @function\n * @param {string} styleStr - Css styles in string format\n * \n * @returns {string} - Content inbetween the {} of the passed in string\n */\nconst getStyleContent = styleStr => {\n  const matches = [ ...styleStr.matchAll(/\\{(.+?)\\}/gi) ]\n  return isArr(matches) && isArr(matches[0]) ? matches[0][1] : ''\n}\n\n/**\n * Converts from css formatted name to js Object format\n * @example\n * cssToJs(\"{ color: blue; font-size: 12px; }\") === { color: 'blue', fontSize: '12px' }\n * @function\n * @param {string} styleStr - Css styles in string format\n * @param {Object} styleObj - Holds the converted styles\n *\n * @returns {Object} - Passed in styleObj, with the styleStr added in object format\n */\nexport const cssToJs = (styleStr, styleObj={}) => {\n  \n  const styles = getStyleContent(styleStr).trim().split(';')\n\n  return styles.reduce((parsed, styleRule) => {\n    if(styleRule.indexOf(':') === -1) return parsed\n\n    let [ name, value ] = styleRule.split(':')\n    name = camelCase(name.trim())\n    value = value.trim()\n\n    return !exists(name) || !exists(value) || name === '' || value === ''\n      ? parsed\n      : { ...parsed, [name]: value }\n\n  }, styleObj)\n\n}\n","import { isArr, checkCall, isObj } from '@keg-hub/jsutils'\nimport { validateArguments } from './validate'\nimport { addToDom } from './addToDom'\nimport { cssToJs } from './cssToJs'\n\n/**\n * Loops a style sheets rules and looks for matching className selectors\n * @function\n * @param {Object} formatted - Object to hold the parsed styles\n * @param {Object} sheet - Dom StyleSheet Object\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {function} callback - Function to call on matching className\n * \n * @returns {Object|string} - CssInJs object or string of the converted styles\n */\nconst loopSheetCssRules = (formatted, sheet, classNames, callback) => {\n  // Check the rules of each styleSheet for a matching class\n  return Array.from(sheet.cssRules)\n    .reduce((formatted, cssRule) => {\n\n      if (!cssRule.selectorText || !cssRule.cssText) return formatted\n\n      // Get the rootSelector of the cssRule, any sub-rule definitions will not work\n      // .my-class-name => WORKS\n      // .root-class-name .my-class-name => DOES NOT WORK\n      const rootSelector = cssRule.selectorText.split(' ').shift()\n\n      // Check if the rootSelector is in the classNames\n      // If it is, then call the callback\n      return classNames.includes(rootSelector)\n        ? checkCall(callback, cssRule, rootSelector, formatted, cssToJs)\n        : formatted\n\n    }, formatted)\n}\n\n/**\n * Loops over the styles sheets currently on the DOM\n * <br/>Searches each one for a matching class within the passed in classNames\n * <br/>If it exists, then it converts it to `data-class-name` attribute\n * @function\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {boolean} [toDom=true] - Should the parsed styles be added to the dom\n * \n * @returns {Object|string} - CssInJs object or string of the converted styles\n */\nexport const styleSheetParser = (args) => {\n\n  const {\n    classNames,\n    callback,\n    toDom=true,\n    valid\n  } = validateArguments(args)\n\n  if(valid === false) return {}\n\n  const parsedStyles = isArr(classNames) &&\n    // Have to convert all styleSheets form the DOM into an array to loop over them\n    Array.from(document.styleSheets).reduce(\n      (formatted, sheet) => loopSheetCssRules(formatted, sheet, classNames, callback),\n      { asStr: '' }\n    )\n\n  toDom &&\n    isObj(parsedStyles) &&\n    parsedStyles.asStr &&\n    addToDom(parsedStyles.asStr)\n\n  return parsedStyles\n\n}\n","import { isArr, isFunc } from '@keg-hub/jsutils'\nimport { hasDomAccess } from '../helpers/hasDomAccess'\n\n/**\n * Validates the passed in arguments to ensure styles can be parsed\n * @function\n * @param {Array} classNames - Array of className to convert into data-attributes\n * @param {boolean} [toDom=true] - Should the parsed styles be added to the dom\n * \n * @returns {Object|boolean} - Passed in args or false if args are invalid\n */\nexport const validateArguments = (args={}) => {\n\n  // Ensure we have dom access and classNames is an array\n  // Otherwise log error an return a string\n  if (!hasDomAccess() || !isArr(args.classNames)){\n    console.error(`[ Error ] styleSheetParser requires Dom Access and an array of class names!`)\n    return { valid: false}\n  }\n\n  // Ensure a callback is passed in\n  if (!isFunc(args.callback)){\n    console.error(`[ Error ] styleSheetParser requires a function callback.\\nIt received:`, args.callback)\n    return { valid: false}\n  }\n\n  return args\n}\n","/**\n * Appends the passed in styles to the DOM\n * @param {string} styles - Style to be added to the dom\n */\nexport const addToDom = styles => {\n\n  const dataCss = document.createElement('style')\n\n  // Based on the browser, we need to set the styles differently\n  dataCss.styleSheet\n    ? (dataCss.styleSheet.cssText = styles)\n    : (dataCss.appendChild(document.createTextNode(styles)))\n\n  // Add the styles to the dom\n  document.getElementsByTagName(\"head\")[0].appendChild(dataCss)\n\n}\n"],"names":["getStyleContent","styleStr","matches","matchAll","isArr","cssToJs","styleObj","styles","trim","split","reduce","parsed","styleRule","indexOf","name","value","camelCase","exists","args","hasDomAccess","classNames","isFunc","callback","console","error","valid","validateArguments","toDom","dataCss","parsedStyles","Array","from","document","styleSheets","formatted","sheet","cssRules","cssRule","selectorText","cssText","rootSelector","shift","includes","checkCall","loopSheetCssRules","asStr","isObj","createElement","styleSheet","appendChild","createTextNode","getElementsByTagName"],"mappings":"2JAWMA,gBAAkB,SAAAC,OAChBC,uBAAeD,EAASE,SAAS,uBAChCC,QAAMF,IAAYE,QAAMF,EAAQ,IAAMA,EAAQ,GAAG,GAAK,IAalDG,QAAU,SAACJ,OAAUK,yDAAS,GAEnCC,EAASP,gBAAgBC,GAAUO,OAAOC,MAAM,YAE/CF,EAAOG,QAAO,SAACC,EAAQC,OACG,IAA5BA,EAAUC,QAAQ,KAAa,OAAOF,QAEnBC,EAAUH,MAAM,6BAAhCK,OAAMC,cACZD,EAAOE,YAAUF,EAAKN,QACtBO,EAAQA,EAAMP,OAENS,SAAOH,IAAUG,SAAOF,IAAmB,KAATD,GAAyB,KAAVC,uCAEhDJ,2BAASG,EAAOC,IADrBJ,IAGHL,6BCK2B,SAACY,SCnCA,eAACA,yDAAK,UAIhCC,kBAAmBf,QAAMc,EAAKE,YAM9BC,SAAOH,EAAKI,UAKVJ,GAJLK,QAAQC,+EAAgFN,EAAKI,UACtF,CAAEG,OAAO,KAPhBF,QAAQC,qFACD,CAAEC,OAAO,IDoCdC,CAAkBR,GAJpBE,IAAAA,WACAE,IAAAA,aACAK,MAAAA,oBAIW,MAHXF,MAGkB,MAAO,OEnDLlB,EAEhBqB,EFmDAC,EAAezB,QAAMgB,IAEzBU,MAAMC,KAAKC,SAASC,aAAavB,QAC/B,SAACwB,EAAWC,UA7CQ,SAACD,EAAWC,EAAOf,EAAYE,UAEhDQ,MAAMC,KAAKI,EAAMC,UACrB1B,QAAO,SAACwB,EAAWG,OAEbA,EAAQC,eAAiBD,EAAQE,QAAS,OAAOL,MAKhDM,EAAeH,EAAQC,aAAa7B,MAAM,KAAKgC,eAI9CrB,EAAWsB,SAASF,GACvBG,YAAUrB,EAAUe,EAASG,EAAcN,EAAW7B,SACtD6B,IAEHA,GA2BqBU,CAAkBV,EAAWC,EAAOf,EAAYE,KACtE,CAAEuB,MAAO,YAGblB,GACEmB,QAAMjB,IACNA,EAAagB,QE9DOtC,EF+DXsB,EAAagB,OE7DlBjB,EAAUI,SAASe,cAAc,UAG/BC,WACHpB,EAAQoB,WAAWT,QAAUhC,EAC7BqB,EAAQqB,YAAYjB,SAASkB,eAAe3C,IAGjDyB,SAASmB,qBAAqB,QAAQ,GAAGF,YAAYrB,IFuD9CC"}