{"version":3,"file":"useTheme-d71dc58d.js","sources":["../../../src/constants/constants.js","../../../src/helpers/hasDomAccess.js","../../../src/dimensions/webDimensions.js","../../../src/theme/themeEvent.js","../../../src/dimensions/sizeMap.js","../../../src/context/platform.js","../../../src/constants/ruleHelpers.js","../../../src/theme/restructureTheme.js","../../../src/theme/manageTheme.js","../../../src/helpers/getTheme.js","../../../src/helpers/joinTheme.js","../../../src/theme/buildTheme.js","../../../src/theme/default.js","../../../src/context/reThemeContext.js","../../../src/hooks/useTheme.js"],"sourcesContent":["import { deepFreeze } from '@keg-hub/jsutils'\n\nexport const Constants = deepFreeze({\n  BUILD_EVENT: 'build',\n  CHANGE_EVENT: 'change',\n  RESIZE_EVENT: 'resize',\n  ADD_EVENT: 'addEventListener',\n  REMOVE_EVENT: 'removeEventListener',\n  KEG_STYLES_TAG_ID: `keg-components-stylesheet`,\n  PLATFORM: {\n    NATIVE: '$native',\n    IOS: '$ios',\n    android: '$android',\n    WEB: '$web',\n    ALL: '$all',\n  },\n})\n","/**\n * Checks if there is access to the dom\n */\nexport const hasDomAccess = () =>\n  !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n","/** @module dimensions */\n\nimport { debounce, isArr, isFunc, checkCall } from '@keg-hub/jsutils'\nimport { Constants } from '../constants'\nimport { hasDomAccess } from '../helpers/hasDomAccess'\n\nconst DEBOUNCE_RATE = 100\n\n/**\n * Gets the window object if it's available\n *\n * @returns {Object} - Browser window object\n */\nconst getWindow = () => {\n  const winAccess = !hasDomAccess()\n\n  return winAccess\n    ? {\n        devicePixelRatio: undefined,\n        innerHeight: undefined,\n        innerWidth: undefined,\n        width: undefined,\n        height: undefined,\n        screen: {\n          height: undefined,\n          width: undefined,\n        },\n      }\n    : (() => {\n        return window\n      })()\n}\n\nconst winDim = getWindow()\n\n/**\n * Adds an event listener to the passed in element\n *\n * @param {*} element - Adds the eventlistener to this param\n * @param {string} event - Event to listen for\n * @param {function} method - Method to call when event fires\n * @param {Object|boolean} options - Options for eventlisteners on browsers\n */\nconst addListener = (element, event, method, options) => {\n  element &&\n    checkCall(element.addEventListener, event, method, options || false)\n}\n\n/**\n * Sets the screen size from the passed in window object\n * @param {Object} win - window object to set the screen size\n *\n * @returns {Object} - Updated screen object\n */\nconst setScreen = win => {\n  return {\n    fontScale: 1,\n    height: win.screen.height,\n    scale: win.devicePixelRatio || 1,\n    width: win.screen.width,\n  }\n}\n\n/**\n * Sets the window size from the passed in window object\n * @param {Object} win - window object to set the screen size\n *\n * @returns {Object} - Updated window object\n */\nconst setWin = win => {\n  return {\n    fontScale: 1,\n    height: win.innerHeight,\n    scale: win.devicePixelRatio || 1,\n    width: win.innerWidth,\n  }\n}\n\n/**\n * Default dimensions object\n */\nconst dimensions = { window: setWin(winDim), screen: setScreen(winDim) }\n\n/**\n * Event listeners cache\n */\nconst listeners = {}\n\n/**\n * Gets a dimensions property based on the passed in value\n * @param {string} dimension - string key name as window || screen\n *\n * @returns {Object} - window or screen property of the dimensions object\n */\nconst get = key => dimensions[key]\n\n/**\n * Sets a dimensions property based on the passed in values\n * @param {Object} dimensions - Object to update the dimensions values\n *\n * @returns {null}\n */\nconst set = ({ screen, window: win }) => {\n  screen && (dimensions.screen = screen)\n  win && (dimensions.window = win)\n}\n\n/**\n * Updates the dimensions object based on the current screen and window sizes\n * Calls any event listeners listening for dimensions updates\n */\nconst update = () => {\n  dimensions.window = setWin(winDim)\n  dimensions.screen = setScreen(winDim)\n\n  isArr(listeners[Constants.CHANGE_EVENT]) &&\n    listeners[Constants.CHANGE_EVENT].forEach(\n      listener => !listener.shouldUnmount && listener(dimensions)\n    )\n}\n\n/**\n * Adds an event listener to the even type\n * @param {string} type - Type of event to listen for\n * @param {function} listener - function to call when the event fires\n *\n */\nconst addEventListener = (type, listener) => {\n  if (!type || !isFunc(listener)) return\n\n  listeners[type] = listeners[type] || []\n  listeners[type].push(listener)\n}\n\n/**\n * Removes an event listener\n * @param {string} type - Type of event to listen for\n * @param {function} listener - function to remove from the event type\n *\n */\nconst removeEventListener = (type, removeListener) => {\n  type &&\n    isFunc(removeListener) &&\n    isArr(listeners[type]) &&\n    (listeners[type] = listeners[type].filter(\n      listener => listener !== removeListener\n    ))\n}\n\n// Check if we have access to the DOM, and if so add a resize event listener\nhasDomAccess() &&\n  checkCall(() =>\n    addListener(window, Constants.RESIZE_EVENT, debounce(update, DEBOUNCE_RATE))\n  )\n\nconst Dimensions = {\n  get,\n  set,\n  update,\n  addEventListener,\n  removeEventListener,\n}\n\nexport { Dimensions }\n","/** @module theme */\n'use strict'\n\nimport { isArr, isFunc, isNum } from '@keg-hub/jsutils'\n\nconst listeners = {}\n\n/**\n * Add a function to an event type\n * <br/> Returns an index which can be used to remove the listener when needed\n * @param {string} event - Names of event to add the listener to\n * @param {function} listener - Listener function to add\n *\n * @returns {number} - Index of the listener in the events array cache\n */\nconst addThemeEvent = (event, listener) => {\n  // Ensure event and listener are passed in correctly\n  if (!event || !isFunc(listener)) return\n\n  // Create the new event event\n  listeners[event] = listeners[event] || []\n\n  // Add the listener to the event event\n  listeners[event].push(listener)\n\n  // Return the index of the added listener\n  return listeners[event].length - 1\n}\n\n/**\n * Remove a registered event listener\n * @param {string} event - Names of event to remove listeners for\n * @param {function} removeListener - Listener function to remove\n *\n * @returns {void}\n */\nconst removeThemeEvent = (event, removeListener) => {\n  // Ensure the proper params are passed in\n  if (!event || !listeners[event] || (!removeListener && removeListener !== 0))\n    return\n\n  // If an index is passed in, use that to remove the listener function\n  isNum(removeListener)\n    ? // Use splice to remove the listener at the correct index\n      listeners[event].splice(removeListener, 1)\n    : // Otherwise ensure the listener and events exists, then filter out the listener\n    isFunc(removeListener) &&\n      isArr(listeners[event]) &&\n      (listeners[event] = listeners[event].filter(\n        listener => listener !== removeListener\n      ))\n}\n\n/**\n * Calls all functions registered to the passed in event name\n * @param {*} event - Event to call listeners for\n * @param {*} params - params to pass to the registered functions\n *\n * @returns {void}\n */\nconst fireThemeEvent = (event, ...params) => {\n  isArr(listeners[event]) &&\n    listeners[event].forEach(listener => listener(...params))\n}\n\n/**\n * Clears registered listeners from the listeners object\n * If event is passed, will only clear listeners for that event\n * @param {string=} event - Name of the event to clear\n *\n * @returns {void}\n */\n// const clearThemeEvents = event => {\n//   event && listeners[event] ? (listeners[event] = []) : (listeners = {})\n// }\n\nexport { addThemeEvent, fireThemeEvent, removeThemeEvent }\n","/** @module dimensions */\n'use strict'\n\nimport {\n  mapObj,\n  isObj,\n  toNum,\n  isNum,\n  softFalsy,\n  logData,\n} from '@keg-hub/jsutils'\n\n/**\n * Default sizes for a screen width\n * <br/> Can be overwritten with setSizes helper\n * @object\n */\nconst sizeMap = {\n  /**\n   * Name of the breakpoint\n   * Number for each entry defines the breakpoint\n   *  > The Breakpoint is the screen size where the entries becomes active\n   */\n  entries: [\n    [ '$xsmall', 1 ],\n    [ '$small', 320 ],\n    [ '$medium', 768 ],\n    [ '$large', 1024 ],\n    [ '$xlarge', 1366 ],\n  ],\n  hash: {},\n  indexes: {},\n}\n\n/**\n * Builds an index of the entry locations in the sizeMap entries\n * <br/>Builds the key value hash of the entries\n * <br/>Builds the keys array of the entries\n * @function\n *\n * @returns {void}\n */\nconst buildSizeMapParts = () => {\n  sizeMap.indexes = sizeMap.entries.reduce((indexes, entry, index) => {\n    // Add the entry value with the index\n    indexes[entry[0]] = index\n\n    // Add the index with entry value\n    indexes[index] = entry[0]\n\n    // Convert the sizeMap.entries into an object of key value pairs\n    sizeMap.hash[entry[0]] = entry[1]\n\n    return indexes\n  }, {})\n}\n\n/**\n * Updates the sizeMap.entries with custom values\n * <br/>Keys must already exist in the default sizeMap.indexes\n * <br/>Allowed keys are => xsmall | small | medium | large | xlarge\n * @function\n * @param {Object} dims - key value pair of custom sizeMap.entries\n *\n * @returns {Object} - Updated sizeMap object\n */\nexport const setSizes = dims => {\n  if (!isObj(dims))\n    return logData(\n      `setDimensions method requires an argument of type 'Object'.\\nReceived: `,\n      dims,\n      'error'\n    )\n\n  mapObj(dims, (key, value) => {\n    // Get the key index from the sizeMap\n    const keyIndex = sizeMap.indexes[key]\n\n    if (!softFalsy(keyIndex))\n      return logData(\n        `Invalid ${key} for theme size! Allowed keys are xsmall | small | medium | large | xlarge`,\n        'warn'\n      )\n\n    // Convert the value to an integer, just a helper incase value is a string\n    const newSize = toNum(dims[key])\n\n    // Ensure key is a valid key in the sizeMap indexes and the new size is a valid number\n    // Also ensure the entry exists based on the keyIndex\n    //  * This should never happen, but just incase\n    if (!newSize || !sizeMap.entries[keyIndex])\n      return logData(\n        `Invalid size entry. Size must be a number and the size entry must exist!`,\n        `Size: ${newSize}`,\n        `Entry: ${sizeMap.entries[keyIndex]}`,\n        'warn'\n      )\n\n    // Use the keyIndex to find the entry\n    // Set the value to be an entry with key and new size\n    sizeMap.entries[keyIndex] = [ key, newSize ]\n  })\n\n  // Rebuild the sizeMap parts after updating the dimensions\n  buildSizeMapParts()\n\n  return sizeMap\n}\n\n/**\n * Helper to get the a size from the sizeMap based on the passed in width\n * @function\n * @param {string|number} width - number to find the size from\n *\n * @returns\n */\nexport const getSize = width => {\n  // Ensure width is a number that can be compared\n  const checkWidth = (isNum(width) && width) || toNum(width)\n\n  const name = sizeMap.entries.reduce((updateSize, [ key, value ]) => {\n    checkWidth >= value\n      ? // If it is check if there is an updateSize already sent\n        updateSize\n          ? // If an update size exists, then check if it's value is less then value\n            value > sizeMap.hash[updateSize] && (updateSize = key)\n          : // Otherwise just update the size\n            (updateSize = key)\n      : null\n\n    return updateSize\n\n    // Default to xsmall size\n  }, '$xsmall')\n\n  return [ name, sizeMap.hash[name] ]\n}\n\n/**\n * Get an array of all sizes to be merged together\n * @function\n * @param {string} key - Name of the size\n *\n * @returns {Array} - Array of size key names\n */\nexport const getMergeSizes = key => {\n  // Add 1 because slice does not include the last item of the range\n  return sizeMap.entries\n    .slice(0, sizeMap.indexes[key] + 1)\n    .map(([ name, size ]) => name)\n}\n\n// Build the default sizeMap parts\nbuildSizeMapParts()\n\n/**\n * Get the sizeMap object\n * @function\n *\n * @returns {Object} - built sizeMap object\n */\nexport const getSizeMap = () => sizeMap\n","import { isObj } from '@keg-hub/jsutils'\n\nconst webDefPlatform = {\n  OS: 'web',\n  select: obj => isObj(obj) && obj.web,\n  Version: 'ReTheme',\n}\n\nlet RNPlatform\nconst getRNPlatform = () => {\n  return RNPlatform || webDefPlatform\n}\n\nconst setRNPlatform = Plat => {\n  RNPlatform = Plat\n}\n\nexport { setRNPlatform, getRNPlatform }\n","export const ruleHelpers = {\n\n  // Margin helpers\n  m: `margin`,\n  mT: `marginTop`,\n  mB: `marginBottom`,\n  mR: `marginRight`,\n  mL: `marginLeft`,\n  mH: `marginHorizontal`,\n  mV: `marginVertical`,\n\n  // Padding helpers\n  p: `padding`,\n  pT: `paddingTop`,\n  pB: `paddingBottom`,\n  pR: `paddingRight`,\n  pL: `paddingLeft`,\n  pH: `paddingHorizontal`,\n  pV: `paddingVertical`,\n\n  // Border helpers\n  bC: `borderColor`,\n  bCT: `borderTopColor`,\n  bCB: `borderBottomColor`,\n  bCR: `borderRightColor`,\n  bCL: `borderLeftColor`,\n  bW: `borderWidth`,\n  bS: `borderStyle`,\n  bC: `borderColor`,\n  bRad: `borderRadius`,\n\n  // Color helpers\n  c: `color`,\n  bg: `background`,\n  bgC: `backgroundColor`,\n\n  // Layout helpers\n  d: `display`,\n  ovf: `overflow`,\n  ovfX: `overflowX`,\n  ovfY: `overflowY`,\n  pos: `position`,\n  z: `zIndex`,\n\n  tp: `top`,\n  bt: `bottom`,\n  btm: `bottom`,\n  lt: `left`,\n  rt: `right`,\n\n  // Effect helpers\n  bxS: `boxShadow`,\n  op: `opacity`,\n  ptrE: `pointerEvents`,\n  otl: `outline`,\n\n  // Flex helpers\n  fl: `flex`,\n  flD: `flexDirection`,\n  flWr: `flexWrap`,\n  flB: `flexBasis`,\n  flS: `flexShrink`,\n  jtC: `justifyContent`,\n  alC: `alignContent`,\n  alS: `alignSelf`,\n  alI: `alignItems`,\n  \n  // Dimension helpers\n  w: 'width',\n  h: `height`,\n  minH: `minHeight`,\n  maxH: `maxHeight`,\n  minW: `minWidth`,\n  maxW: `maxWidth`,\n  \n  // Text / Font helpers\n  ftF: `fontFamily`,\n  ftSz: `fontSize`,\n  ftS: `fontStyle`,\n  ftWt: `fontWeight`,\n  lnH: `lineHeight`,\n  ltrS: `letterSpacing`,\n  txAl: `textAlign`,\n  txDc: `textDecoration`,\n  txDL: 'textDecorationLine',\n}","/** @module theme */\n'use strict'\n\nimport { ruleHelpers } from '../constants/ruleHelpers'\nimport { getSizeMap } from '../dimensions'\nimport { Constants } from '../constants'\nimport { getRNPlatform } from '../context/platform'\nimport {\n  isObj,\n  deepMerge,\n  reduceObj,\n  isEmpty,\n  unset,\n  get,\n} from '@keg-hub/jsutils'\n\n// Default platforms to use when restructuring the theme\n// Use array, so we don't lose the order\nconst getDefaultPlatforms = () => {\n  const Platform = getRNPlatform()\n  // Rules for the OS platform ( web || ios || android )\n  const stylePlatforms = ['$' + get(Platform, 'OS')]\n\n  // If it's not a web platform, then add the $native platform\n  if (get(Platform, 'OS') !== 'web') stylePlatforms.push('$native')\n\n  // Rules for all platforms and os's\n  return stylePlatforms.concat([Constants.PLATFORM.ALL])\n}\n\n/**\n * Joins the passed in user platform with the default platforms array\n * @param {Object} usrPlatforms - use defined platforms to use when building the theme\n *\n * @returns {Array} - Contains platforms to use when building the theme\n */\nconst buildPlatforms = usrPlatforms => {\n  const platsToUse = Object.keys(usrPlatforms).filter(key => usrPlatforms[key])\n\n  return getDefaultPlatforms().reduce((platforms, plat) => {\n    usrPlatforms[plat] !== false &&\n      platforms.indexOf(plat) === -1 &&\n      platforms.unshift(plat)\n\n    return platforms\n  }, platsToUse)\n}\n\n/**\n * Searches the theme object for keys that match the passed in size\n * <br/> Maps any found size key objects to the sizedTheme object\n * @function\n * @param {Object} theme - Contains theme style rules\n * @param {Object} sizedTheme - Holds the theme styles for the current size\n * @param {string} size - Current size to search the theme for\n *\n * @returns {Object} theme with the sizes moved to the root level\n */\nconst buildSizedThemes = (theme, sizedTheme, size) => {\n  return reduceObj(\n    theme,\n    (name, value, sizedTheme) => {\n\n      // Check if the name is a shortcut\n      if(ruleHelpers[name]){\n        unset(theme, name)\n        theme[ruleHelpers[name]] = value\n      }\n\n      // If value is not an object, just return the sizedTheme\n      if (!isObj(value)) return sizedTheme\n\n      // If we find the size in the theme, join it with the current sizedTheme\n      if (name === size) {\n        // Merge the current sizedTheme, with the value for this size\n        const mergedSize = deepMerge(sizedTheme, value)\n\n        // Remove the size from the theme\n        // Because it gets moved to the size theme section\n        unset(theme, [size])\n\n        // Return the merged size\n        return mergedSize\n      }\n\n      // Call buildSizedThemes for the values object to look for  sizes in child objects\n      const subSized = buildSizedThemes(value, sizedTheme[name] || {}, size)\n\n      // If the subSized contains keys, then it has size data\n      // So set it to the name for this size\n      if (!isEmpty(subSized)) sizedTheme[name] = subSized\n\n      // Return the updated sized theme\n      return sizedTheme\n    },\n    sizedTheme\n  )\n}\n\n/**\n * Merges styles of any that exist within the platforms object and the theme\n * <br/> If no platforms exists, just return the theme\n * @function\n * @param {Object} theme - Current theme object that holds the style rules\n * @param {boolean} platforms - Platforms to use when building the theme\n *\n * @returns - Merged platform theme rules, or the passed in theme if no rules exist\n */\nconst mergePlatformOS = (theme, platforms) => {\n  const sizeMap = getSizeMap()\n\n  const toMerge = []\n  // Loop the platforms and check if they are allowed and the platform exist on theme\n  // If is a valid platform add to the toMerge array\n  const mergeTheme = Object.keys(theme)\n    .reduce((cleanTheme, key) => {\n      key[0] === '$' && !sizeMap.hash[key]\n        ? platforms.indexOf(key) !== -1 && toMerge.push(theme[key])\n        : (cleanTheme[key] = theme[key])\n\n      return cleanTheme\n    }, {})\n\n  // If any of the platform theme object exist, then merge them together\n  // Otherwise just return the passed in theme object\n  return toMerge.length ? deepMerge(...toMerge) : mergeTheme\n}\n\nconst updatePlatformTheme = (platforms, Platform, themeData) => {\n  // If the themeData is not an object, then just return it\n  // Because we've hit the rules for this tree in the theme\n  if(!isObj(themeData)) return themeData\n\n  // Extract the class && className\n  const { $class, $className, ...cleanTheme } = themeData\n\n  const mergedPlatform = getPlatformTheme(\n    mergePlatformOS(cleanTheme, platforms),\n    platforms,\n    Platform\n  )\n\n  const className = $className || $class\n  className && (mergedPlatform.$class = className)\n\n  return mergedPlatform\n  \n}\n\n/**\n * Traverse through the theme to find any keys matching the current platform\n * <br/> Once a platform key is found, any sub-keys of that object are not searched\n * @function\n * @example:\n * # If platform is web\n * const theme = { font: { web: { size: 12, native: {} }, native: { size: 10 } } }\n * const platformTheme = getPlatformTheme(theme)\n * # returns { font: { size: 12, native: {} }}\n *\n * @param {Object} themes - each theme module, keys are names and values are the theme rules\n * @param {boolean} platforms - Platforms to use when building the theme\n *\n * @returns {Object} - Update theme object with platform keys updated\n */\nconst getPlatformTheme = (theme, platforms, Platform = {}) => {\n  if (!theme) return theme\n\n  return reduceObj(\n    theme,\n    (key, value, platformTheme) => {\n    \n      // Update the current get correct value for the platform key\n      platformTheme[key] = updatePlatformTheme(platforms, Platform, value)\n\n      // Return the update platformTheme object\n      return platformTheme\n\n      // Use the theme as the original platformTheme to return\n    },\n    theme\n  )\n}\n\n/**\n * Traverse through the theme to find any size objects matching this size\n * <br/> Adds them to the root size object, and removes from the default paht\n * @function\n * @example:\n * const meetings = { fontSize: 12, small: { fontSize: 10 } }\n * restructureTheme({ meetings })\n * # returns => { small: { meetings: { fontSize: 10 }, meetings: { fontSize: 12 } }\n *\n * @param {Object} themes - each theme module, keys are names and values are the theme rules\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} - sized theme object with sizes moved to root size object\n */\nexport const restructureTheme = (theme, usrPlatform = {}) => {\n  const Platform = getRNPlatform()\n\n  // Use the theme based on the platform if it exists\n  // Pass in the response after the sizes are set\n  // Loop over the size map hash keys\n  return Object.keys(getSizeMap().hash).reduce((updatedTheme, size) => {\n    // traverse through the theme to find any size objects matching this size\n    const builtSize = buildSizedThemes(theme, theme[size] || {}, size)\n\n    // If builtSize is not empty, then size data was found, so set it to the updatedTheme object\n    if (!isEmpty(builtSize)) updatedTheme[size] = builtSize\n\n    return updatedTheme\n  }, getPlatformTheme(theme, buildPlatforms(usrPlatform), Platform))\n}\n","/**\n * Holds the current theme after it's built\n */\nlet currentTheme = {}\n\n/**\n * Helper to allow other methods to get the current theme used by the provider\n * @returns {Object} currentTheme - Current theme used by the provider\n */\nexport const getCurrentTheme = () => currentTheme\n\n/**\n * Helper to update the current Theme when ever the theme is built\n * Gets added as an event listener, and is called every time the theme is re-built\n * @param {Object} updatedTheme - Update built theme\n */\nexport const updateCurrentTheme = updatedTheme => (currentTheme = updatedTheme)\n","import { deepMerge, get, isArr, isObj, isStr } from '@keg-hub/jsutils'\nimport { getCurrentTheme } from '../theme/manageTheme'\n\n/**\n * Merges the styles from the passed in sources\n * @param {Array} sources - An array of strings, arrays or objects\n *                          If it's a string or array, it searches the theme using get\n *                          If it's a object, it merges it with the other found objects\n *\n * @returns {Object} - built theme styles object\n */\nexport const getTheme = function (...sources) {\n  const theme = getCurrentTheme()\n\n  // Build the styles by merging the sources together\n  // Check if each source is an id to cache or get the styles from the theme\n  return deepMerge(\n    ...sources.reduce((toMerge, source) => {\n      const styles = isObj(source)\n        ? source\n        : isStr(source) || isArr(source)\n          ? get(theme, source)\n          : null\n\n      styles && toMerge.push(styles)\n\n      return toMerge\n    }, [])\n  )\n}\n","import { isArr, isObj, get } from '@keg-hub/jsutils'\nimport { getTheme } from './getTheme'\n\n/**\n * Checks if the passed in arguments match an object array pattern\n * <br/> Which checks is the first argument is a ReTheme object, and the second is an array of paths\n * @param {Object} arg1 - Checks if this is the root ReTheme Object\n *\n * @returns {boolean} - T/F if the passed in arguments match\n */\nconst hasManyFromTheme = arg1 => isObj(arg1) && isObj(arg1.RTMeta)\n\n/**\n * Joins rules from the theme together. Accepts unlimited rules objects\n * <br/> Subset rules can be passed in as an array of key names on the theme to join together\n * <br/> Or the the actual rules objects should be passed in\n * @param {Object} arg1 - Theme, or subset of theme rules\n * @param {Object|Array} arg2 - Subset of theme rules or an array of keys to join from the theme\n * @param {Array} sources - Array of subset theme rules to join together\n *\n * @returns {Object} - Joined theme rules\n */\nexport const joinTheme = (arg1, arg2, ...sources) => {\n\n  process.env.NODE_ENV !== 'production' && console.warn(\n    `[ ReTheme WARN ] - theme.join is deprecated!`,\n    `\\nIt will be removed in an upcoming release.`,\n    `\\nUse theme.get instead!`\n  )\n\n  sources = !isArr(arg2)\n    ? [arg2].concat(sources)\n    : [ ...(arg2.map(arg => (isObj(arg) && arg) || (arg && get(arg1, arg)))), ...sources ]\n\n  return hasManyFromTheme(arg1, arg2)\n    ? getTheme(...sources)\n    : getTheme(arg1, ...sources)\n\n}\n","/** @module theme */\n'use strict'\n\nimport { fireThemeEvent } from './themeEvent'\nimport { Constants } from '../constants'\nimport { getMergeSizes, getSize } from '../dimensions'\nimport { isObj, deepMerge, checkCall } from '@keg-hub/jsutils'\nimport { restructureTheme } from './restructureTheme'\nimport { updateCurrentTheme, getCurrentTheme } from './manageTheme'\nimport { getTheme } from '../helpers/getTheme'\nimport { joinTheme } from '../helpers/joinTheme'\n\n/**\n * Holds the cached merged theme with sizes\n * <br/> Tracks if the theme didn't change, but the size did\n * <br/> Only calls joinThemeSizes instead of restructureTheme\n * @object\n */\nlet themeSizeCache = {}\n\n/**\n * Joins themes from different sizes together based on the index of the sizeKey\n * <br/> It takes the all sizes less then the index of the sizeKey, included in the sizeKey\n * <br/> Then loops over each one and joins them together\n * @function\n * @param {Object} theme - Parent theme object, which holds the child themes organized by their size keys (e.g. $small)\n * @param {string} sizeKey - Name of the current window size\n * @param {Object} [extraTheme={}] - Extra theme items to add to the theme, has lowest priority\n *\n * @returns {Object} - Merged theme\n */\nconst joinThemeSizes = (theme, sizeKey, extraTheme = {}) => {\n  const sizesToMerge = getMergeSizes(sizeKey)\n  return deepMerge(\n    // Add the extra theme first, so it has lowest priority\n    extraTheme,\n    // Get the sizes to merge, and map to the theme\n    ...sizesToMerge.reduce((themes, key) => {\n      // Check if a theme exists for the passed in key\n      // And add it to the themes array\n      theme[key] && themes.push(theme[key])\n\n      return themes\n    }, [])\n  )\n}\n\n/**\n * Checks if the theme is the same as the default theme.\n * <br/> If not then merges the two together.\n * <br /> Also, adds the size themes at the root of the resulting object\n * @function\n * @param {Object} theme - Passed in user there\n * @param {Object} defaultTheme - Cached default theme\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} - Theme object\n */\nconst mergeWithDefault = (theme, defaultTheme, usrPlatform) => {\n  // Check if theres a defaultTheme, and it's not equal to the passed in theme\n  const mergedTheme =\n    defaultTheme && theme !== defaultTheme\n      ? deepMerge(defaultTheme, theme)\n      : deepMerge({}, theme)\n\n  // Build the sizes for the merged theme based on the sizeMap keys\n  return restructureTheme(mergedTheme, usrPlatform)\n}\n\n/**\n * Gets the dimensions of the current screen, and pull the theme if it exists\n * @function\n * @param {Object} theme - Current active theme\n * @param {number} width - Current screen width\n * @param {number} height - Current screen height\n * @param {Object} defaultTheme - Initial theme\n * @param {boolean} usrPlatform - Use a custom user theme Platform\n *\n * @returns {Object} Subsection of the theme based on current dimensions if it exists\n */\nexport const buildTheme = (theme, width, height, defaultTheme, usrPlatform) => {\n\n  // If theres no theme, or not valid curSize, just return the passed in theme\n  if (!isObj(theme)) return theme\n  if (!isObj(usrPlatform)) usrPlatform = {}\n\n  // Pull out the key and the size that matches the width\n  const [ key, size ] = getSize(width)\n  const RTMeta = { key, size, width, height }\n\n  // Check if the theme has changed since the last time it was built\n  // If not, then short-circuit, and call useCachedTheme with cache data\n  if(themeSizeCache && theme === themeSizeCache.theme)\n    return useCachedTheme(themeSizeCache, RTMeta)\n\n  const mergedTheme = mergeWithDefault(theme, defaultTheme, usrPlatform)\n\n  // Extract the sizes from the theme\n  const {\n    $xsmall,\n    $small,\n    $medium,\n    $large,\n    $xlarge,\n    ...extraTheme\n  } = mergedTheme\n\n  themeSizeCache = { extraTheme, mergedTheme, theme, key }\n\n  return configureBuiltTheme(themeSizeCache, RTMeta)\n}\n\n/**\n * Gets the correct cached theme based on if Viewport size has changed \n * @function\n * @param {Object} themeSizeCache - Cache theme data containing the sizes\n * @param {Object} themeSizeCache.mergedTheme - The full theme with sizes\n * @param {Object} themeSizeCache.extraTheme - The full theme without sizes\n * @param {string} themeSizeCache.key - keg size from the last time the theme was built\n * @param {Object} RTMeta - Meta data about the current state of the theme\n * @param {string} RTMeta.key - Current size key from the size map\n *\n * @returns {Object} Current theme object with the sizes merged\n */\nconst useCachedTheme = (themeSizeCache, RTMeta) => {\n  return RTMeta.key !== themeSizeCache.key\n    ? configureBuiltTheme(themeSizeCache, RTMeta)\n    : checkCall(() => {\n        const currentTheme = getCurrentTheme()\n        fireThemeEvent(Constants.BUILD_EVENT, currentTheme)\n        return currentTheme\n      })\n}\n\n/**\n * Configures the built theme with the correct sizes, helpers and meta data\n * @function\n * @param {Object} themeSizeCache - Cache theme data containing the sizes\n * @param {Object} themeSizeCache.mergedTheme - The full theme with sizes\n * @param {Object} themeSizeCache.extraTheme - The full theme without sizes\n * @param {string} themeSizeCache.key - keg size from the last time the theme was built\n * @param {Object} RTMeta - Meta data about the current state of the theme\n * @param {string} RTMeta.key - Current size key from the size map\n *\n * @returns {Object} Current theme object with the sizes merged\n */\nconst configureBuiltTheme = ({ mergedTheme,  extraTheme }, RTMeta) => {\n\n  // Update the key for the new size\n  // So next compare will use the correct key\n  themeSizeCache.key = RTMeta.key\n\n  const builtTheme = !RTMeta.size\n    ? extraTheme\n    : joinThemeSizes(mergedTheme, RTMeta.key, extraTheme)\n\n  // Add the get and join helpers\n  builtTheme.get = getTheme\n  builtTheme.join = joinTheme\n\n  builtTheme.RTMeta = { ...builtTheme.RTMeta, ...RTMeta }\n\n  updateCurrentTheme(builtTheme)\n\n  fireThemeEvent(Constants.BUILD_EVENT, builtTheme)\n\n  return builtTheme\n}\n","/** @module theme */\n'use strict'\n\nimport { deepMerge, isObj } from '@keg-hub/jsutils'\nimport { Dimensions } from 'ReDimensions'\nimport { buildTheme } from './buildTheme'\n\n/**\n * Holds the default theme which can be set with the setDefaultTheme helper\n */\nlet defaultTheme = {}\n\n/**\n * Overwrites the default them with passed in theme\n * If merge is passed as true, will merge the current default theme with the passed in theme\n * @param {Object} [theme={}] - Theme to overwrite of merge with the default theme\n * @param {boolean} [merge=false] - Should the passed in theme be merged with the default theme\n * @param {boolean} useDimensions - Should subset theme that matches current dimensions\n *\n * @returns {void}\n */\nexport const setDefaultTheme = (theme, merge = false) => {\n  // Ensure the passed in theme is an object\n  if (!isObj(theme))\n    return console.warn(\n      `setDefaultTheme method requires an theme object as the first argument. Received: `,\n      theme\n    )\n\n  // Check if the default theme should be merged, or overwritten\n  defaultTheme = merge ? deepMerge(defaultTheme, theme) : theme\n\n  // Get subset theme that matches current dimensions is useDimensions is true\n  const dims = Dimensions.get('window')\n  const useTheme = buildTheme(defaultTheme, dims.width, dims.height)\n\n  // Return the newly set default theme\n  return useTheme\n}\n\n/**\n * Gets the default theme\n *\n * @returns {Object} - the default theme\n */\nexport const getDefaultTheme = () => defaultTheme\n","/** @module context */\n'use strict'\n\nimport React from 'react'\nimport { getDefaultTheme } from '../theme/default'\n\n/**\n * Creates the initial theme context\n */\nexport const ReThemeContext = React.createContext(getDefaultTheme())\n","/** @module hooks */\n\nimport { useContext } from 'react'\nimport { ReThemeContext } from '../context/reThemeContext'\n\n/**\n * Uses the useContext hook from react to get the current theme ( Value prop of the context )\n *\n * @returns { Object } - Current theme\n */\nexport const useTheme = () => {\n  return useContext(ReThemeContext)\n}\n"],"names":["Constants","deepFreeze","BUILD_EVENT","CHANGE_EVENT","RESIZE_EVENT","ADD_EVENT","REMOVE_EVENT","KEG_STYLES_TAG_ID","PLATFORM","NATIVE","IOS","android","WEB","ALL","hasDomAccess","window","document","createElement","winDim","devicePixelRatio","undefined","innerHeight","innerWidth","width","height","screen","setScreen","win","fontScale","scale","setWin","dimensions","listeners","update","isArr","forEach","listener","shouldUnmount","checkCall","element","event","method","debounce","addEventListener","options","Dimensions","get","key","set","type","isFunc","push","removeEventListener","removeListener","filter","fireThemeEvent","params","sizeMap","entries","hash","indexes","buildSizeMapParts","reduce","entry","index","getSize","checkWidth","isNum","toNum","name","updateSize","value","getMergeSizes","slice","map","RNPlatform","getSizeMap","ruleHelpers","m","mT","mB","mR","mL","mH","mV","p","pT","pB","pR","pL","pH","pV","bC","bCT","bCB","bCR","bCL","bW","bS","webDefPlatform","OS","select","obj","isObj","web","Version","getRNPlatform","buildPlatforms","usrPlatforms","Platform","stylePlatforms","platsToUse","Object","keys","concat","platforms","plat","indexOf","unshift","buildSizedThemes","theme","sizedTheme","size","reduceObj","unset","mergedSize","deepMerge","subSized","isEmpty","updatePlatformTheme","themeData","$class","$className","cleanTheme","mergedPlatform","getPlatformTheme","toMerge","mergeTheme","length","mergePlatformOS","className","platformTheme","currentTheme","getCurrentTheme","getTheme","sources","source","styles","isStr","hasManyFromTheme","arg1","RTMeta","joinTheme","arg2","arg","themeSizeCache","mergeWithDefault","defaultTheme","usrPlatform","updatedTheme","builtSize","restructureTheme","buildTheme","useCachedTheme","mergedTheme","extraTheme","$xsmall","$small","$medium","$large","$xlarge","configureBuiltTheme","builtTheme","sizeKey","sizesToMerge","themes","joinThemeSizes","join","getDefaultTheme","ReThemeContext","React","createContext","splice","merge","console","warn","dims","useTheme","Plat","mapObj","keyIndex","softFalsy","logData","newSize","useContext"],"mappings":"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"}