{"version":3,"file":"match-312736a1.js","sources":["../../src/method/noOp.js","../../src/method/isOrderable.js","../../src/method/compareTo.js","../../src/method/identity.js","../../src/method/match.js"],"sourcesContent":["/** @module functions */\n\nimport { deepFreeze } from '../object/deepFreeze'\n\n/**\n * Reusable empty function that is a no-op\n * @function\n * @returns {void}\n */\nexport const noOp = () => {}\n\n/**\n * Reuseable empty, frozen object\n * @type {Object}\n */\nexport const noOpObj = Object.freeze({})\n\n/**\n * Resuable frozen object that contains a `content` object. Useful\n * for themes that rely on the content key.\n * @type {Object}\n */\nexport const noPropObj = deepFreeze({ content: {} })\n\n/**\n * Reusable, empty frozen array\n * @type {Array}\n */\nexport const noPropArr = deepFreeze([])","/** @module functions */\n\nimport { isStr } from '../string'\nimport { isBool } from '../boolean'\nimport { isNum } from '../number'\n\n/**\n * Checks if param is an orderable primitive\n * @function\n * @param {*} x \n * @returns {bool} - true if x is a comparable primitive\n */\nexport const isOrderable = x => isStr(x) || isNum(x) || isBool(x)","/** @module method */\n\nimport { isStr } from '../string'\nimport { isOrderable } from './isOrderable'\nimport { validate } from '../validation'\n\n/**\n * @function\n * Generic compare to method that works for strings, numbers, and booleans\n * @param {string | number | boolean} x \n * @param {string | number | boolean} y \n * @return { number | null } - returns a value < 0 if x is less than y, 0 if they are equal, and a value greater than 0 if x is greater than y. Returns null if the args are not comparable.\n */\nexport const compareTo = (x, y) => {\n  const [ valid ] = validate({ x, y }, { $default: isOrderable }) \n  if (!valid) return null\n  return isStr(x)\n    ? (x.localeCompare(y))\n    : (x - y)\n}","/** @module functions */\n\n/**\n * A function that simply returns its input\n * @function\n * @param {*} x \n * @returns {*} the input\n */\nexport const identity = x => x","/** @module functions */\n\nimport { isArr } from '../array/isArr'\nimport { typeOf } from '../ext/typeOf'\nimport { isFunc } from './isFunc'\n\n/**\n* Pattern matching function. Iterates through the entries,\n* which have the form [ check value or predicate, return value ], and\n* when it encounters an entry whose check value matches the matchArg\n* (or the predicate returns true when passed the matchArg), it returns\n* the return value of that entry.\n*\n* For the default case: use [ match.default, <your default value> ]\n* @function\n*\n* @param {*} matchArg - the argument to match against the cases\n* @param {Array} entries - the cases\n* @returns the return value of the first entry with a matching check value, else null\n*\n* @example \n* const value = 1\n* match(value,\n*  [ 1, \"hello\" ],\n*  [ x => x > 2, \"greater\" ] \n*  [ match.default, \"defaulted\"]\n* ) \n* => returns \"hello\"\n* \n* @example \n* const value = 3\n* match(value,\n*  [ 1, \"hello\" ],\n*  [ x => x > 2, \"greater\" ] \n* ) \n* => returns \"greater\"\n*\n* @example \n* // react reducer:\n*function todoReducer(state, action) {\n*   const reducer = match(action.type,\n*       [ 'ADD-TODO', addTodo ],\n*       [ 'REMOVE-TODO', removeTodo ],\n*       [ 'UPDATE-TODO', updateTodo ],\n*       [ match.default, state ]\n*   )\n*\n*   return reducer(state, action)\n*}\n*/\nexport const match = (matchArg, ...args) => {\n  if (!args.length) return null\n\n  // check all cases and return a value if a match is found\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(`Matching case must be an entry (a 2-element array). Found: ${typeOf(entry)}`, entry)\n      break\n    }\n    const [ caseValueOrPredicate, valueOnMatch ] = entry\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg)) return valueOnMatch\n    if (caseValueOrPredicate === matchArg) return valueOnMatch\n  }\n\n  return null\n}\n\n/**\n * The default case function you can use with match. Just returns true so the case value can be used.\n * @function\n * @example\n * match(foo\n *    [ 100, 'a' ],\n *    [ 200, 'b' ],\n *    [ match.default, 'default value' ]\n * )\n */\nmatch.default = () => true\n\n"],"names":["noOp","noOpObj","Object","freeze","noPropObj","deepFreeze","content","noPropArr","isOrderable","x","isStr","isNum","isBool","compareTo","y","valid","validate","$default","localeCompare","identity","match","matchArg","args","length","entry","isArr","console","error","typeOf","caseValueOrPredicate","valueOnMatch","isFunc","default"],"mappings":";;;;;;;;;MASaA,IAAI,GAAG,MAAM;MAMbC,OAAO,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd;MAOVC,SAAS,GAAGC,UAAU,CAAC;AAAEC,EAAAA,OAAO,EAAE;AAAX,CAAD;MAMtBC,SAAS,GAAGF,UAAU,CAAC,EAAD;;MChBtBG,WAAW,GAAGC,CAAC,IAAIC,KAAK,CAACD,CAAD,CAAL,IAAYE,KAAK,CAACF,CAAD,CAAjB,IAAwBG,MAAM,CAACH,CAAD;;MCCjDI,SAAS,GAAG,CAACJ,CAAD,EAAIK,CAAJ,KAAU;AACjC,QAAM,CAAEC,KAAF,IAAYC,QAAQ,CAAC;AAAEP,IAAAA,CAAF;AAAKK,IAAAA;AAAL,GAAD,EAAW;AAAEG,IAAAA,QAAQ,EAAET;AAAZ,GAAX,CAA1B;AACA,MAAI,CAACO,KAAL,EAAY,OAAO,IAAP;AACZ,SAAOL,KAAK,CAACD,CAAD,CAAL,GACFA,CAAC,CAACS,aAAF,CAAgBJ,CAAhB,CADE,GAEFL,CAAC,GAAGK,CAFT;AAGD;;MCXYK,QAAQ,GAAGV,CAAC,IAAIA;;MC0ChBW,KAAK,GAAG,CAACC,QAAD,EAAW,GAAGC,IAAd,KAAuB;AAC1C,MAAI,CAACA,IAAI,CAACC,MAAV,EAAkB,OAAO,IAAP,CADwB;AAI1C,OAAK,IAAIC,KAAT,IAAkBF,IAAlB,EAAwB;AACtB,QAAI,CAACG,KAAK,CAACD,KAAD,CAAV,EAAmB;AACjBE,MAAAA,OAAO,CAACC,KAAR,CAAe,8DAA6DC,MAAM,CAACJ,KAAD,CAAQ,EAA1F,EAA6FA,KAA7F;AACA;AACD;AACD,UAAM,CAAEK,oBAAF,EAAwBC,YAAxB,IAAyCN,KAA/C;AACA,QAAIO,MAAM,CAACF,oBAAD,CAAN,IAAgCA,oBAAoB,CAACR,QAAD,CAAxD,EAAoE,OAAOS,YAAP;AACpE,QAAID,oBAAoB,KAAKR,QAA7B,EAAuC,OAAOS,YAAP;AACxC;AAED,SAAO,IAAP;AACD;AAYDV,KAAK,CAACY,OAAN,GAAgB,MAAM,IAAtB;;;;"}