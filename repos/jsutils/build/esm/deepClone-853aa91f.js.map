{"version":3,"file":"deepClone-853aa91f.js","sources":["../../src/collection/set.js","../../src/collection/deepClone.js"],"sourcesContent":["/** @module collection */\n\nimport { updateColl } from './updateColl'\n\n/**\n * Adds a path to an object.\n * <br> If the path already exists, but not in the correct format it will be replaced.\n * <br> The path is built from a `.` separated string.\n * <br> I.E. path = 'data.foo.bar' => obj.data.foo.bar will be created on the object.\n * @example\n * set(obj, [ 'foo', 'bar' ], 'baz')\n * // Returns the passed in obj, with the value of bar set to baz\n * @example\n * set(obj, 'foo.bar', 'baz')\n * // Returns the passed in obj, with the value of bar set to baz\n * @function\n * @param {Object} obj - object to have the path added to it\n * @param {string|array} path - path that should be created on the object, separated by .\n * @param {*} finalValue - when ever the final value of the path should be\n * @return {Object} the obj param\n */\nexport const set = (obj, path, val) => (\n  updateColl(obj, path, 'set', val)\n)\n","/** @module collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { cloneFunc } from '../method/cloneFunc'\nimport { isArr } from '../array/isArr'\n\n/**\n * Recursively clones an object or array.\n  * @example\n * const test = { foo: [ { bar: 'baz' } ] }\n * const clone = deepClone(test)\n * console.log(test === clone)) // prints false\n * console.log(test.foo === clone.foo) // prints false\n * @example\n * // Works with array too\n * deepClone([ [ [ 0 ] ] ])\n * // Returns copy of the passed in collection item\n * @function\n * @param {Object} obj - object to clone\n * @return {Object} - cloned Object\n */\nexport const deepClone = (obj, hash = new WeakMap()) => {\n  if (Object(obj) !== obj) return obj\n  if (obj instanceof Set) return new Set(obj)\n  if (hash.has(obj)) return hash.get(obj)\n  if (isArr(obj)) return obj.map(x => deepClone(x))\n  if (isFunc(obj)) return cloneFunc(obj)\n\n  const result = obj instanceof Date \n    ? new Date(obj)\n    : obj instanceof RegExp \n      ? new RegExp(obj.source, obj.flags)\n      : (!obj.constructor)\n        ? Object.create(null)\n        : null\n  \n  // if result is null, object has a constructor and wasn't an instance of Date nor RegExp\n  if (result === null) return cloneObjWithPrototypeAndProperties(obj)\n\n  hash.set(obj, result)\n\n  if (obj instanceof Map)\n    return Array.from(obj, ([key, val]) => result.set(key, deepClone(val, hash)) )\n\n  return Object\n    .assign(\n      result,\n      ...Object.keys(obj)\n        .map(key => ({ [key]: deepClone(obj[key], hash) }))\n    )\n}\n\n/**\n * Helper for deepClone. Deeply clones the object, including its properties, and preserves the prototype and isFrozen and isSealed state\n * @function\n * @ignore\n * @param {Object} objectWithPrototype - any object that has a prototype\n * @returns {Object} the cloned object \n */\nexport const cloneObjWithPrototypeAndProperties = (objectWithPrototype) => {\n\n  if (!objectWithPrototype) return objectWithPrototype\n\n  const prototype = Object.getPrototypeOf(objectWithPrototype)\n  const sourceDescriptors = Object.getOwnPropertyDescriptors(objectWithPrototype)\n\n  for (const [key, descriptor] of Object.entries(sourceDescriptors)) {\n    descriptor.value &&\n      ( sourceDescriptors[key].value = deepClone(descriptor.value) )\n  }\n\n  const clone = Object.create(prototype, sourceDescriptors)\n\n  if (Object.isFrozen(objectWithPrototype)) Object.freeze(clone)\n  if (Object.isSealed(objectWithPrototype)) Object.seal(clone)\n\n  return clone \n}\n"],"names":["set","obj","path","val","updateColl","deepClone","hash","WeakMap","Object","Set","has","get","isArr","map","x","isFunc","cloneFunc","result","Date","RegExp","source","flags","constructor","create","cloneObjWithPrototypeAndProperties","Map","Array","from","key","assign","keys","objectWithPrototype","prototype","getPrototypeOf","sourceDescriptors","getOwnPropertyDescriptors","descriptor","entries","value","clone","isFrozen","freeze","isSealed","seal"],"mappings":"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"}