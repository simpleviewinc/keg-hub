{"version":3,"file":"index.js","sources":["../../src/validation/validate.js","../../src/array/isArr.js","../../src/array/areFrequencyEqual.js","../../src/object/isObj.js","../../src/method/isFunc.js","../../src/method/applyToFunc.js","../../src/method/pipeline.js","../../src/string/isStr.js","../../src/string/mapString.js","../../src/string/isLowerCase.js","../../src/string/isUpperCase.js","../../src/string/delimitString.js","../../src/string/capitalize.js","../../src/string/removeDot.js","../../src/string/cleanStr.js","../../src/string/camelCase.js","../../src/string/toStr.js","../../src/string/sanitize.js","../../src/collection/isColl.js","../../src/collection/updateColl.js","../../src/collection/get.js","../../src/string/template.js","../../src/boolean/isBool.js","../../src/boolean/isStrBool.js","../../src/boolean/convertToStrBool.js","../../src/boolean/softFalsy.js","../../src/boolean/toBool.js","../../src/number/equalsNaN.js","../../src/number/isNum.js","../../src/number/isNonNegative.js","../../src/number/getNums.js","../../src/number/toNum.js","../../src/method/isOrderable.js","../../src/method/compareTo.js","../../src/method/identity.js","../../src/object/hasOwn.js","../../src/method/uuid.js","../../src/method/cloneFunc.js","../../src/ext/typeOf.js","../../src/method/match.js","../../src/object/deepFreeze.js","../../src/method/noOp.js","../../src/array/findExtrema.js","../../src/array/uniqArr.js","../../src/collection/cleanColl.js","../../src/collection/set.js","../../src/collection/deepEqual.js","../../src/collection/deepClone.js","../../src/ext/strToType.js","../../src/log/log.js","../../src/object/clearObj.js","../../src/object/deepMerge.js","../../src/object/isEntry.js","../../src/object/mapEntries.js","../../src/object/reduceObj.js","../../src/promise/promisify.js","../../src/promise/promisifyAll.js","../../src/url/queryToObj.js","../../src/object/applyToCloneOf.js","../../src/array/areSetEqual.js","../../src/string/buildPath.js","../../src/string/camelCasePath.js","../../src/method/checkCall.js","../../src/array/cloneArr.js","../../src/object/cloneJson.js","../../src/method/complement.js","../../src/string/containsStr.js","../../src/method/debounce.js","../../src/method/doIt.js","../../src/ext/either.js","../../src/array/eitherArr.js","../../src/method/eitherFunc.js","../../src/object/eitherObj.js","../../src/string/eitherStr.js","../../src/object/everyEntry.js","../../src/ext/exists.js","../../src/object/filterObj.js","../../src/array/findMax.js","../../src/array/findMin.js","../../src/array/flatMap.js","../../src/url/getURLParam.js","../../src/object/isArrMap.js","../../src/string/isEmail.js","../../src/ext/isEmpty.js","../../src/collection/isEmptyColl.js","../../src/number/isFloat.js","../../src/number/isInt.js","../../src/number/isNegative.js","../../src/string/isPhone.js","../../src/number/isPositive.js","../../src/ext/isSame.js","../../src/string/isUrl.js","../../src/string/isUuid.js","../../src/ext/isValidDate.js","../../src/url/isValidUrl.js","../../src/object/jsonEqual.js","../../src/object/keyMap.js","../../src/method/limbo.js","../../src/collection/mapColl.js","../../src/object/mapKeys.js","../../src/object/mapObj.js","../../src/method/memorize.js","../../src/number/nth.js","../../src/url/objToQuery.js","../../src/object/omitKeys.js","../../src/array/omitRange.js","../../src/string/parseJSON.js","../../src/object/pickKeys.js","../../src/string/plural.js","../../src/array/randomArr.js","../../src/array/randomizeArr.js","../../src/collection/reduceColl.js","../../src/collection/repeat.js","../../src/object/sanitizeCopy.js","../../src/collection/shallowEqual.js","../../src/string/singular.js","../../src/string/snakeCase.js","../../src/object/someEntry.js","../../src/string/styleCase.js","../../src/method/throttle.js","../../src/method/throttleLast.js","../../src/number/toFloat.js","../../src/number/toInt.js","../../src/object/toObj.js","../../src/string/trainCase.js","../../src/object/trimStringFields.js","../../src/collection/unset.js","../../src/promise/wait.js","../../src/string/wordCaps.js"],"sourcesContent":["/** @module validation */\n\nconst OPTIONS = {\n  SHOULD_LOG: true,\n  SHOULD_THROW: false,\n  LOG_PREFIX: null\n}\n\n/** \n *  Validates each key-value entry in argObj using the validator functions in validators with matching keys. \n *  For any failures, validate will console.error the reason.\n *  @param { Object } argObj - object, where keys are the name of the argument to validate, and value is its value\n *  @param { Object } validators - object, where keys match the argument and values are predicate functions (return true/false and are passed the arg with the same key). \n *     - Use the `$default` key to define a default validator, which will validate any argument that doesn't have a custom validator defined.\n *  @param { Object } options - contains `logs` and `throws` props. When a validation fails, it will throw an error if `throws` is true. Else it logs error if `logs` is true.\n *  @returns { Array } - an entry with two values [ success, results ]. \n *     - success: { Boolean } that is true if all arguments passed their validators, false otherwise\n *     - results: { Object } that holds the validation results for each argument, keyed by the same keys as in argObj. For each\n *                result object, the properties are: { success, key, value, validator, reason }.\n *  @function\n *  @example \n *    const elements = {}\n *    const name = 'michael'\n *    const address = '12345 E. Street'\n *    const [ isValid, results ] = validate(\n *      { elements, name, address },\n *      { elements: isArr, $default: isStr }\n *    )\n *    console.log(isValid) // false\n *    console.log(results.elements.success) // false\n */\nexport const validate = (argObj, validators={}, { logs=OPTIONS.SHOULD_LOG, throws=OPTIONS.SHOULD_THROW, prefix=OPTIONS.LOG_PREFIX }={}) => {\n  const validationCaseEntries = Object.entries(argObj)\n\n  // if no default or custom validator set for an arg, just assert it is valid\n  const defaultValidator = () => true\n\n  // validate each argument\n  const validationResults = validationCaseEntries.map(\n    ([argName, argValue]) => validateArgument(\n      argName,\n      argValue,\n      validators[argName] || validators['$default'] || defaultValidator\n    )\n  )\n\n  // reduce the argument validation results into a single object of form { success, cases }.\n  // success is true if all arguments passed their validators. Cases holds each argument's validation results.\n  const reduceCases = (total, next) => validationReducer(total, next, { logs, throws, prefix })\n  const { success, cases } = validationResults.reduce(reduceCases, { success: true, cases: {} })\n\n  return [ success, cases ]\n}\n\n/**\n * If you need to configure validation properties globally, you can do so here. These are overridden by the validate options arguments,\n * if one is defined in validate().\n * @function\n * @param {Object} options \n * @param {Boolean} options.logs - indicates you want validate() to log errors when a case fails\n * @param {Boolean} options.throws - indicates validate() should throw an error when a case fails\n * @param {String} options.prefix - a prefix to any console error logs or to messages of errors thrown\n */\nvalidate.setOptions = ({ logs, throws, prefix }) => {\n  if (logs !== undefined) {\n    OPTIONS.SHOULD_LOG = logs\n  }\n  if (throws !== undefined) {\n    OPTIONS.SHOULD_THROW = throws\n  }\n  if (prefix !== undefined) {\n    OPTIONS.LOG_PREFIX = prefix\n  }\n}\n\n/**\n * Resets the global validation options to their defaults\n * @function\n */\nvalidate.resetOptions = () => {\n  OPTIONS.SHOULD_LOG = true\n  OPTIONS.SHOULD_THROW = false\n  OPTIONS.LOG_PREFIX = null\n}\n\n/**\n * Helper for `validate`. Validates a single value given a validator\n * @param {*} key \n * @param {*} value \n * @param {Function} validator \n * @returns {Object} of form { success, reason }\n * @ignore\n */\nconst validateArgument = (key, value, validator) => {\n  const success = validator(value)\n\n  // if validator is a named function, use its name. If it is an inline anonymous arrow function, its name\n  // matches the argument key and it has no useful/descriptive name, so just stringify it\n  const shouldStringifyValidator = !validator.name || (validator.name === key) || (validator.name === '$default')\n  const validatorString = shouldStringifyValidator ? validator.toString() : validator.name\n\n  const reason = success\n    ? null\n    : [\n      `Argument \"${key}\" with value `, \n      value, \n      ` failed validator: ${validatorString}.`\n    ] \n   \n  return { success, key, value, validator, reason }\n}\n\n/**\n * Helper for `validate`. Reduces validations into a single object of form { success, cases }\n * @param {*} finalResult\n * @param {*} nextValidation\n * @ignore\n */\nconst validationReducer = (finalResult, nextValidation, { logs, throws, prefix }) => {\n  // handle the failure\n  !nextValidation.success && handleFailure(nextValidation, logs, throws, prefix)\n\n  return {\n    success: finalResult.success && nextValidation.success,\n    cases: {\n      ...finalResult.cases,\n      [nextValidation.key]: nextValidation\n    }\n  }\n}\n\n/**\n * Handles a validation failure given validation options\n * @param {Object} validation \n * @param {Boolean} shouldLog \n * @param {Boolean} shouldThrow \n * @param {String} prefix - optional prefix to any error or console log \n * @ignore\n */\nconst handleFailure = (validation, shouldLog, shouldThrow, prefix) => {\n  // prepend the prefix if one is defined\n  const reason = prefix\n    ? [ prefix, ...validation.reason ]\n    : validation.reason\n\n  if (shouldThrow)\n    throw new Error(reason.join())\n  \n  if (shouldLog)\n    console.error(...reason)\n}\n","/** @module array */\n\n/**\n * Checks if passed in value is an array.\n * @function\n * @example\n * isArr([1,2,3])\n * // Returns true\n * @param {any} value - value to be check if is an array\n * @return {boolean} - T/F value is an array\n */\nexport const isArr = value => (\n  Array.isArray(value)\n)","/** @module array */\n\nimport { validate } from '../validation'\nimport { isArr } from './isArr'\n\n/**\n * Builds a map of elements mapped to their frequency counts\n * @param {Array<*>} arr \n * @return {Map<*, number>}\n */\nexport const buildElementCountMap = arr => {\n  const counts = new Map()\n  for (let i = 0; i < arr.length; i++) {\n    const element = arr[i]\n    const count = counts.get(element) ?? 0\n    counts.set(element, count + 1)\n  }\n  return counts\n}\n\n/**\n * Returns true if the maps \n * @param {Map<*, number>} mapA \n * @param {Map<*, number>} mapB \n */\nexport const areCountMapsEqual = (mapA, mapB) => {\n  if (mapA.size !== mapB.size) return false\n\n  for (let [ key, count ] of mapA) {\n    const otherCount = mapB.get(key)\n    if (otherCount !== count) return false\n  }\n\n  return true\n}\n\n/**\n * Checks if arrays are frequency equal. Does this \n * by making only one pass over each array and using an\n * auxilliary map.\n * @function\n * @param {Array<*>} arr \n * @param {Array<*>} otherArr \n * @returns {boolean} true if otherArr contains exactly the same elements as arr, \n * where order does not matter, but frequency does\n */\nexport const areFrequencyEqual = (arr, otherArr) => {\n  const [ valid ] = validate({ arr, otherArr }, { $default: isArr })\n  if (!valid) return null\n\n  if (arr === otherArr) return true\n  if (arr.length !== otherArr.length) return false\n\n  const arrCounts = buildElementCountMap(arr)\n  const otherCounts = buildElementCountMap(otherArr)\n\n  return areCountMapsEqual(arrCounts, otherCounts)\n}\n","/** @module object */\n\n/**\n * Checks if data is an object and not an array.\n * @function\n * @param {Object} obj - data to check\n * @returns {boolean}\n */\nexport const isObj = obj => typeof obj === 'object' && !Array.isArray(obj) && obj !== null\n","/** @module functions */\n\n/**\n * Check if the passed in item is a function.\n * @example\n * isFunc(() => {})\n * // Returns true\n * @example\n * isFunc('bar')\n * // Returns false\n * @function\n * @param {*} test\n * @return {boolean} is a function\n */\nexport const isFunc = func => typeof func === 'function'\n","/** @module functions */\n\nimport { isArr } from '../array/isArr'\nimport { isFunc } from './isFunc'\n\n/**\n * Helper for pipeline. Passes 'item' into 'expression' as its first argument.\n * <br> Expression may be a function or an array of form: [function, ...remainingArguments].\n * @function\n * @param {*} item \n * @param {*} expression \n */\nexport const applyToFunc = (item, expression) => {\n  if (isArr(expression)) {\n    const [func, ...args] = expression\n    return func(item, ...args)\n  }\n  else if (isFunc(expression)) {\n    return expression(item) \n  }\n  else {\n    console.error(`Pipeline expected either a function or an array (for function expressions). Found ${typeof expression}`)\n    return item\n  }\n}\n","/** @module functions */\n\nimport { applyToFunc } from './applyToFunc'\n\n/**\n * Function for making repeated nested function calls (the 'pipeline') succinct. Passes \"item\" into\n * <br> the first function (as its first argument), takes its result and passes that into the next function, and repeats.\n * <br> Continues until no functions remain, at which point it returns the value returned by the last function.\n * <br>  - you can also pass in an array in place of a function to specify a function to be called with some arguments. E.g.: [foo, 2, 3] would return foo(item, 2, 3)\n * @example: pipeline(1, addFour, subtract3, (x) => x * x) // would return 4\n * @function\n * @param {* | Function} item - the starting input. If it is a function, it will be executed immediately and the result will be piped into the remaining functions.\n * @param {...Function} functions \n * @returns the final result of calling the pipeline of functions , starting with item as input\n */\nexport const pipeline = (item, ...functions) => {\n  return functions.reduce(\n    (result, fn) => applyToFunc(result, fn),\n    item\n  )\n}\n","/** @module string */\n\n/**\n * Check if passed in value is a string.\n * @function\n * @param { all } str - param to check if type is a string \n * @return {boolean} - if it's a string\n */\nexport const isStr = str => typeof str === 'string'\n","/** @module string */\n\nimport { isFunc } from '../method/isFunc'\nimport { isStr } from './isStr'\n\n/**\n * Maps a string by applying function `charMapper` to each character.\n * @function\n * @param {string} str to be mapped\n * @param {Function} charMapper - function of form (character) => <some character or string>\n * @returns a new string, with each character mapped by charMap. If str is not a string or charMapper not a function, just returns str\n * @example\n *  mapString(\"hello\", c => c === 'h' ? 'x' : c) // returns 'xello'\n */\nexport const mapString = (str, charMapper) => {\n  if (!isStr(str)) return str\n  if (!isFunc(charMapper)) return str\n  let result = \"\"\n  for (const char of str) {\n    result += charMapper(char)\n  }\n  return result\n}","/** @module string */\n\n/**\n * @function\n * @returns true if str is upper case\n * @param {String} str \n */\nexport const isLowerCase = str => (str === str.toLowerCase())\n\n","/** @module string */\n\n/**\n * @function\n * @returns true if str is upper case\n * @param {String} str \n */\nexport const isUpperCase = str => (str === str.toUpperCase())\n","/** @module string */\n\nimport { isStr } from './isStr'\nimport { mapString } from './mapString'\nimport { isLowerCase } from './isLowerCase'\nimport { isUpperCase } from './isUpperCase'\n\n/**\n * @function\n * @returns a new string with the specified delimiter delimiting each word\n * @param {String} str - string of any casing\n * @param {String} delimiter - e.g. '_'\n * @param {Array} delimiters - optional. An array of delimiter characters on which this function searches and breaks. Defaults to checking -, _, and space\n * @example delimitString('fooBar', '_') // 'foo_Bar'\n */\nexport const delimitString = (str, delimiter, delimiters=['-', '_', ' ']) => {\n  if (!isStr(str)) return str\n  const isDelimiter = c => delimiters.some(del => del === c)\n  let prevChar = '_'\n  return mapString(str, char => {\n    if (isDelimiter(char)) {\n      prevChar = delimiter \n      return delimiter \n    }\n\n    if (isUpperCase(char) && isLowerCase(prevChar) && !isDelimiter(prevChar)) {\n      prevChar = char\n      return delimiter + char\n    }\n\n    prevChar = char\n    return char\n  })\n}\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts first letter of a string to be capitalized.\n * @function\n * @param {string} string\n * @param {boolean} lowercaseTail - if true, will also lowercase the all characters except the first\n * @return {string} - Passed in string, but capitalized\n */\nexport const capitalize = (str, lowercaseTail=true) => {\n  if (!isStr(str) || !str[0]) return str\n  const tail = lowercaseTail\n    ? str.slice(1).toLowerCase()\n    : str.slice(1)\n  return `${str[0].toUpperCase()}${tail}`\n}\n","/** @module string */\n\n/**\n * Removes a `.` from the start and end of a string.\n * @function\n * @param {string} str - string to convert\n * @return {string} - string without the `.`\n */\nexport const removeDot = string => {\n  const noDot = string.indexOf('.') === 0 ? string.slice(1) : string\n  return noDot.indexOf('.') === noDot.length - 1 ? noDot.slice(0, -1) : noDot\n}\n","/** @module string */\n\nimport { removeDot } from './removeDot'\n\n\n/**\n * Converts `-` and `_` to white space and calls remove removeDot, to remove a period.\n * @function\n * @param {string} string to be converted\n * @return {string} - cleaned string\n */\nexport const cleanStr = str => {\n  return str && removeDot(str)\n    .replace(/[-_]/gm, ' ') || str\n}\n","/** @module string */\n\nimport { capitalize } from './capitalize'\nimport { cleanStr } from './cleanStr'\n\n/**\n * Converts a string to camel case.\n * @function\n * @param {string} string to be converted\n * @return {string} - string in camel case format\n */\nexport const camelCase = (str, compCase) => {\n  return (\n    (str &&\n      cleanStr(str)\n        .split(/[\\s_-]/gm)\n        .reduce((cased, word, index) => {\n          if(!word) return cased\n          cased += ((index > 0 || compCase) && capitalize(word)) || word.toLowerCase()\n          return cased\n        }, '')\n      ) || str\n  )\n}\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts a passed in value to a string.\n * @function\n * @param {*} val - value to be converted\n * @return {string} - value converted into a string\n */\nexport const toStr = val => (\n  val === null || val === undefined\n    ? ''\n    : isStr(val)\n      ? val\n      : JSON.stringify(val)\n)\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Sanitize a string of HTML content.\n * @function\n * @param {string} string\n * @return {string} - cleaned string\n */\nexport const sanitize = str => (\n  isStr(str) && str\n    .replace(/&/g,'&amp;')\n    .replace(/</g,'&lt;')\n    .replace(/>/g,'&gt;') || str\n)\n","/** @module collection */\n\n/**\n * Checks if the value is a collection ( object || array ).\n * @example\n * isColl([1,2,3])\n * // Returns true\n * @example\n * isColl({ foo: 'bar' })\n * // Returns true\n * @example\n * isColl(null)\n * // Returns false\n * @function\n * @param {*} val - value to check\n * @return {boolean} T/F if the value is a collection\n */\nexport const isColl = val => (\n  typeof val === 'object' && val !== null\n)\n","/** @module collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { isArr } from '../array/isArr'\nimport { isColl } from './isColl'\n\n/**\n * Updates a collection by removing, getting, adding to it.\n * @memberof collection\n * @param {Object} obj - object to update\n * @param {string|array} path - path to the property to update\n * @param {*} type - value to update || type\n * @return {*} based on update method\n */\nexport const updateColl = (obj, path, type, val) => {\n  const org = obj\n  if (!isColl(obj) || !obj || !path)\n    return type !== 'set' && val || undefined\n  \n  // cloneDeep so we don't modify the reference\n  const parts = isArr(path) ? Array.from(path) : path.split('.')\n  const key = parts.pop()\n  let prop\n  let breakPath\n\n  while (prop = parts.shift()) {\n    const next = obj[prop]\n\n    isColl(next) || isFunc(next)\n      ? ( obj = next )\n      : (() => {\n          if(type === 'set') obj[prop] = {}\n          else breakPath = true\n          obj = obj[prop]\n        })()\n\n    if (breakPath) return val\n  }\n\n  return type === 'get'\n    // Get return the value\n    ? key in obj\n      ? obj[key]\n      : val\n    : type === 'unset'\n      // Unset, return if the key was removed\n      ? ( delete obj[key] )\n      // Set, updated object\n      : ( obj[key] = val ) && org || org\n}\n","/** @module collection */\n\nimport { updateColl } from './updateColl'\n\n/**\n * Searches an object based on the path param\n * <br> I.E. path = 'data.foo.bar' => will return obj.data.foo.bar.\n * <br> If bar does not exist, then will return obj.data.foo\n * @example\n * get(obj, 'data.foo.bar')\n * // Returns the value of bar\n * @example\n * get(obj, ['data', 'foo', 'bar'])\n * // Returns the value of bar\n * @function\n * @param {Object} obj - will search the object based on the path\n * @param {string|array} path - . separated string to search the object\n * @return the final value found from the path\n */\nexport const get = (obj, path, fallback) => (\n  updateColl(obj, path, 'get', fallback)\n)\n","/** @module string */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from '../collection/isColl'\nimport { get } from '../collection/get'\nimport { isStr } from './isStr'\n/**\n * Simple template replace for ES6 template strings\n * @function\n * @example\n * template('${ who } in ${ where }!', { who: 'goats', where: 'boats' })\n * // Returns \"goats in boats\"\n * @param {string} template - String with ES6 syntax items to be replaced\n * @param {Object|Array} data - Data used to replace the ES6 placeholders\n * @param {any} fallback - Used it data does not contain key to be replaced\n *\n * @returns {string} - template with placeholder values filled\n */\nexport const template = (tempStr, data, fallback='') => {\n  data = isColl(data) && data || {}\n  const regex = template.regex || /\\${([^{]+[^}])}/g\n\n  return isStr(tempStr)\n    ? tempStr.replace(regex, (match, exact) => {\n      const path = (exact || match.substr(2, match.length - 3)).trim()\n      const replaceWith = get(data, path, fallback)\n      return isFunc(replaceWith)\n        ? replaceWith(data, path, fallback)\n        : replaceWith\n\n    })\n    : console.error(`template requires a string as the first argument`) || tempStr\n}","/** @module boolean */\n\n/**\n * Checks is value is a boolean.\n * @function\n * @example\n * isBool([1,2,3])\n * // Returns false\n * @example\n * isBool(true)\n * // Returns true\n * @param {*} val - value to check if is a number\n * @return {boolean} T/F - if value is a boolean\n */\nexport const isBool = val => (\n  typeof val === 'boolean'\n)\n","/** @module boolean */\n\n/**\n * Checks is value is a boolean as a string.\n * @function\n * @example\n * isStrBool(\"true\")\n * // Returns true\n * @example\n * isStrBool(true)\n * // Returns false\n * @param {*} val - value to check if boolean as a string\n * @return {boolean} T/F - if value is a boolean\n */\nexport const isStrBool = val => (\n  val === 'false' || val === 'true'\n)\n\n","/** @module boolean */\n\nimport { toStr } from '../string/toStr'\nimport { isBool } from './isBool'\n\n/**\n * Converts a value to a boolean as a string.\n * @function\n * @example\n * convertToStrBool(true)\n * // Returns 'true'\n * @param {*} val - value to convert\n * @return {string} 'true' || 'false' based on passed in value\n */\nexport const convertToStrBool = val => (\n  isBool(val)\n    ? toStr(val)\n    : !val || val === 'false' || val === '0'\n      ? 'false'\n      : 'true'\n)\n","/** @module boolean */\n\n/**\n * Checks if a value is falsy, excluding empty string and 0.\n * @function\n * @example\n * softFalsy('')\n * // Returns true\n * @example\n * softFalsy(0)\n * // Returns true\n * @example\n * softFalsy(null)\n * // Returns false\n * @param {*} val - value to check\n * @return {boolean} T/F based on passed in value\n */\nexport const softFalsy = val => (\n  Boolean(val || val === '' || val === 0)\n)\n","/** @module boolean */\n\nimport { isStrBool } from './isStrBool'\nimport { convertToStrBool } from './convertToStrBool'\n\n/**\n * Converts a value to a boolean.\n * @function\n * @example\n * toBool(null)\n * // Returns false\n * @example\n * toBool('false')\n * // Returns false\n * @example\n * toBool('true')\n * // Returns true\n * @param {*} val - value to convert\n * @return {boolean} true or false based on passed in value.\n */\nexport const toBool = val => (\n  isStrBool(val)\n    ? val === 'true'\n    : convertToStrBool(val) === 'true'\n)","/** @module number */\n\n/**\n * Checks if a value is NaN.\n * @example\n * equalsNaN(NaN)\n * // Returns true\n * @example\n * equalsNaN(1)\n * // Returns false\n * @example\n * equalsNaN('')\n * // Returns false\n * @function\n * @param {number} val - value to check if is NaN\n * @return {boolean} T/F - if value is a number\n */\nexport const equalsNaN = val => (\n  typeof val === 'number' && val != val\n)\n","/** @module number */\n\nimport { equalsNaN } from './equalsNaN'\n\n/**\n * Checks is value is a number.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt(NaN)\n * // Returns false\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {number} val - value to check if is a number\n * @return {boolean} T/F - if value is a number\n */\nexport const isNum = val => (\n  typeof val === 'number' && !equalsNaN(val)\n)\n","/** @module number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if val is a non-negative number\n * @param {*} val \n * @example\n *  isNonNegative(0) // true\n *  isNonNegative(1) // true\n *  isNonNegative(-1) // false\n * @function\n * @returns T/F - if value is non negative number\n */\nexport const isNonNegative = val => isNum(val) && (val >= 0)\n","/** @module number */\n\nimport { toStr } from '../string/toStr'\n\n/**\n * Gets numbers and floats (.) from a string.\n * @example\n * getNums('$1.23')\n * // Returns '1.23'\n * @function\n * @param {*} val - value to pull numbers from\n * @return {string} Numbers found in value\n */\nexport const getNums = val => (\n  toStr(val).replace(/([^.\\d])/gm,'')\n)\n","/** @module number */\n\nimport { equalsNaN } from './equalsNaN'\nimport { getNums } from './getNums'\nimport { isNum } from './isNum'\n\n/**\n * Converts passed in value to a number.\n * @example\n * toNum(\"23\")\n * // Returns 23\n * @example\n * toNum(NaN)\n * // Returns 0\n * @function\n * @param {*} val - value to convert\n * @return {number} value converted to a float\n */\nexport const toNum = val => (\n  isNum(val)\n    ? val\n    : val &&\n      !equalsNaN(val) && \n      Number(getNums(val)) ||\n      0\n)\n","/** @module functions */\n\nimport { isStr } from '../string'\nimport { isBool } from '../boolean'\nimport { isNum } from '../number'\n\n/**\n * Checks if param is an orderable primitive\n * @function\n * @param {*} x \n * @returns {bool} - true if x is a comparable primitive\n */\nexport const isOrderable = x => isStr(x) || isNum(x) || isBool(x)","/** @module method */\n\nimport { isStr } from '../string'\nimport { isOrderable } from './isOrderable'\nimport { validate } from '../validation'\n\n/**\n * @function\n * Generic compare to method that works for strings, numbers, and booleans\n * @param {string | number | boolean} x \n * @param {string | number | boolean} y \n * @return { number | null } - returns a value < 0 if x is less than y, 0 if they are equal, and a value greater than 0 if x is greater than y. Returns null if the args are not comparable.\n */\nexport const compareTo = (x, y) => {\n  const [ valid ] = validate({ x, y }, { $default: isOrderable }) \n  if (!valid) return null\n  return isStr(x)\n    ? (x.localeCompare(y))\n    : (x - y)\n}","/** @module functions */\n\n/**\n * A function that simply returns its input\n * @function\n * @param {*} x \n * @returns {*} the input\n */\nexport const identity = x => x","/** @module object */\n\n/**\n * Checks if prop exists on the object.\n * @function\n * @param {Object} obj - data to check\n * @param {string} prop - prop to check for\n * @returns {boolean} T/F if the prop exists\n */\nexport const hasOwn = (obj, prop) => (\n  Object.prototype.hasOwnProperty.call(obj, prop)\n)\n","/** @module functions */\n\n/**\n * Creates a uuid, unique up to around 20 million iterations.\n * @example\n * uuid()\n * // New uuid as a string\n * @function\n * @param {number} start of the uuid\n * @return {string} - build uuid\n */\nexport const uuid = a => a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([ 1e7 ] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g,uuid)\n","/** @module functions */\n\nimport { get } from '../collection/get'\n\n/**\n * Clones a function using the Function constructor and calling toString on the passed in function\n * @example\n * const func = () => { console.log('test') }\n * const clone = cloneFunc(func)\n * // clone !== func\n * @function\n * @param {function} func - function to clone\n *\n * @returns {Object} cloned function\n */\nexport const cloneFunc = func => {\n\n  const funcClone = function(...args){\n    return func instanceof funcClone\n      ? (() => { return new func(...args) })()\n      : get(func.prototype, 'constructor.name')\n        ? new func(...args)\n        : func.apply(func, args)\n  }\n\n  for(let key in func )\n    func.hasOwnProperty(key) && (funcClone[key] = func[key])\n  \n  Object.defineProperty(funcClone, 'name', { value: func.name, configurable: true })\n  funcClone.toString = () => func.toString()\n\n  return funcClone\n}\n","/** @module Helpers */\n\n/**\n * Gets the type of the passed in val.\n * @example\n * typeOf(1)\n * // Returns Number\n * @example\n * typeOf('')\n * // Returns String\n * @function\n * @param {*} val - value to get type for\n * @return {string} type of the value\n */\nexport const typeOf = val => (\n  Object.prototype.toString.call(val).slice(8, -1)\n)\n","/** @module functions */\n\nimport { isArr } from '../array/isArr'\nimport { typeOf } from '../ext/typeOf'\nimport { isFunc } from './isFunc'\n\n/**\n* Pattern matching function. Iterates through the entries,\n* which have the form [ check value or predicate, return value ], and\n* when it encounters an entry whose check value matches the matchArg\n* (or the predicate returns true when passed the matchArg), it returns\n* the return value of that entry.\n*\n* For the default case: use [ match.default, <your default value> ]\n* @function\n*\n* @param {*} matchArg - the argument to match against the cases\n* @param {Array} entries - the cases\n* @returns the return value of the first entry with a matching check value, else null\n*\n* @example \n* const value = 1\n* match(value,\n*  [ 1, \"hello\" ],\n*  [ x => x > 2, \"greater\" ] \n*  [ match.default, \"defaulted\"]\n* ) \n* => returns \"hello\"\n* \n* @example \n* const value = 3\n* match(value,\n*  [ 1, \"hello\" ],\n*  [ x => x > 2, \"greater\" ] \n* ) \n* => returns \"greater\"\n*\n* @example \n* // react reducer:\n*function todoReducer(state, action) {\n*   const reducer = match(action.type,\n*       [ 'ADD-TODO', addTodo ],\n*       [ 'REMOVE-TODO', removeTodo ],\n*       [ 'UPDATE-TODO', updateTodo ],\n*       [ match.default, state ]\n*   )\n*\n*   return reducer(state, action)\n*}\n*/\nexport const match = (matchArg, ...args) => {\n  if (!args.length) return null\n\n  // check all cases and return a value if a match is found\n  for (let entry of args) {\n    if (!isArr(entry)) {\n      console.error(`Matching case must be an entry (a 2-element array). Found: ${typeOf(entry)}`, entry)\n      break\n    }\n    const [ caseValueOrPredicate, valueOnMatch ] = entry\n    if (isFunc(caseValueOrPredicate) && caseValueOrPredicate(matchArg)) return valueOnMatch\n    if (caseValueOrPredicate === matchArg) return valueOnMatch\n  }\n\n  return null\n}\n\n/**\n * The default case function you can use with match. Just returns true so the case value can be used.\n * @function\n * @example\n * match(foo\n *    [ 100, 'a' ],\n *    [ 200, 'b' ],\n *    [ match.default, 'default value' ]\n * )\n */\nmatch.default = () => true\n\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Recursively freezes and object.\n * @function\n * @param {Object} obj\n * @return {Object} - frozen Object\n */\nexport const deepFreeze = obj => {\n  Object.freeze(obj)\n  Object\n    .getOwnPropertyNames(obj)\n    .map(prop => {\n      obj.hasOwnProperty(prop)\n        && obj[prop] !== null\n        && (typeof obj[prop] === 'object' || isFunc(obj[prop]))\n        && !Object.isFrozen(obj[prop])\n        && deepFreeze(obj[prop])\n    })\n\n  return obj\n}\n","/** @module functions */\n\nimport { deepFreeze } from '../object/deepFreeze'\n\n/**\n * Reusable empty function that is a no-op\n * @function\n * @returns {void}\n */\nexport const noOp = () => {}\n\n/**\n * Reuseable empty, frozen object\n * @type {Object}\n */\nexport const noOpObj = Object.freeze({})\n\n/**\n * Resuable frozen object that contains a `content` object. Useful\n * for themes that rely on the content key.\n * @type {Object}\n */\nexport const noPropObj = deepFreeze({ content: {} })\n\n/**\n * Reusable, empty frozen array\n * @type {Array}\n */\nexport const noPropArr = deepFreeze([])","/** @module array */\n\nimport { isArr } from './isArr'\nimport { isFunc } from '../method'\nimport { validate } from '../validation'\n\n/**\n * Finds the extremum (e.g. max, min) element within array `arr` as defined by the `comparator` function\n * @function\n * @param {Array<*>} arr \n * @param {Function} comparator - comparison function like the compareFunction in sort: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n * @returns {*} the element in `arr` that is the extremum as defined by `comparator`. If arr is empty, this function returns null.\n * @example\n * const max = findExtrema([ { a: 1 }, { a: 2} ], (x, y) => x.a - y.a)\n * // max === { a: 2 } \n */\nexport const findExtrema = (arr, comparator) => {\n  const [ valid ] = validate({ arr, comparator }, { arr: isArr, $default: isFunc })\n  if (!valid) return null\n\n  return arr.length\n    ? arr.reduce(\n        (extremaSoFar, next) => (comparator(extremaSoFar, next) > 0 ? extremaSoFar : next)\n      )\n    : null\n}\n","/** @module array */\n\nimport { isArr } from './isArr'\n\n/**\n * Removes duplicates from an array, checking by reference-equality\n * @function\n * @example\n * uniqArr([1,1,2,3,3])\n * // Returns array with only unique values [ 1, 2, 3 ]\n * @param {array} arr - array to remove duplicates from\n * @return {array} copy of passed in array, with duplicates removed\n */\nexport const uniqArrByReference = (arr) => {\n  return !isArr(arr)\n    ? arr\n    : arr.filter((e, i, arr) => arr.indexOf(e) == i\n  )\n}\n\n/**\n * \n * @param {*} arr \n * @param {*} selector \n */\n/**\n * Removes duplicates from an array.\n * @function\n * @example\n * uniqArr([1,1,2,3,3])\n * // Returns array with only unique values [ 1, 2, 3 ]\n * @example\n * uniqArr([ {a: 1} , { a: 1 }], element => element.a)\n * // Returns array [ { a: 1 } ]\n * @param {array} arr - array to remove duplicates from\n * @param {Function?} selector - optional function to specify the property uniqArr should use to check if another element exists\n * @return {array} copy of passed in array, with duplicates removed\n */\nexport const uniqArr = (arr, selector) => {\n  if (!selector) return uniqArrByReference(arr)\n\n  // loop over each element in one pass, \n  // only including in the unique array elements\n  // we haven't encountered before \n  // by checking with `selector` and the set\n  const { unique } = arr.reduce(\n    (data, element) => {\n      const id = selector(element)\n      !data.set.has(id) && data.unique.push(element)\n      data.set.add(id)\n      return data\n    },\n    { \n      unique: [], \n      set: new Set()\n    }\n  )\n\n  return unique\n}","/** @module collection */\n\nimport { isObj } from '../object/isObj'\nimport { isColl } from './isColl'\n\n/**\n * Cleans a collection by creating a new collection\n * With the null and undefined values removed\n * @function\n * @param {Object|Array} coll - Collection to remove empty values from\n * @param {boolean} [recursive=true] - Should recursively clean child values\n *\n * @returns {Object|Array} - Cleaned collection\n */\nexport const cleanColl = (coll, recursive=true) => {\n  return isColl(coll)\n    ? Object.keys(coll)\n      .reduce((cleaned, key) => {\n        const value = coll[key]\n        if(value === null || value === undefined) return cleaned\n\n        cleaned[key] = recursive && isColl(value)\n          ? cleanColl(value)\n          : value\n\n        return cleaned\n      }, isObj(coll) && {} || [])\n    : console.error(`cleanColl requires a collection as the first argument`) || coll\n}","/** @module collection */\n\nimport { updateColl } from './updateColl'\n\n/**\n * Adds a path to an object.\n * <br> If the path already exists, but not in the correct format it will be replaced.\n * <br> The path is built from a `.` separated string.\n * <br> I.E. path = 'data.foo.bar' => obj.data.foo.bar will be created on the object.\n * @example\n * set(obj, [ 'foo', 'bar' ], 'baz')\n * // Returns the passed in obj, with the value of bar set to baz\n * @example\n * set(obj, 'foo.bar', 'baz')\n * // Returns the passed in obj, with the value of bar set to baz\n * @function\n * @param {Object} obj - object to have the path added to it\n * @param {string|array} path - path that should be created on the object, separated by .\n * @param {*} finalValue - when ever the final value of the path should be\n * @return {Object} the obj param\n */\nexport const set = (obj, path, val) => (\n  updateColl(obj, path, 'set', val)\n)\n","/** @module collection */\n\n// Cache the prototype methods for faster access\nconst isArray = Array.isArray\nconst keyList = Object.keys\nconst hasProp = Object.prototype.hasOwnProperty\n\n/**\n * Recursively checks if two collections are equal\n * <br/>Faster the JSON.stringify checks\n * <br/>See https://jsperf.com/fast-deep-equal-vs-json-stringify\n * @example\n * const test = { foo: [ { bar: 'baz' } ] }\n * const test2 = { foo: [ { bar: 'baz' } ] }\n * console.log(test === test2)) // prints false\n * deepEqual(test, test2) // returns true\n * @example\n * // Works with arrays too\n * deepClone([ [ [ 0 ] ] ], [ [ [ 0 ] ] ]) // returns true\n * @function\n * @param {Object|Array} a - object to check\n * @param {Object|Array} b - object to check against\n */\nexport const deepEqual = (a, b) => {\n  if (a === b) return true\n\n  if(!a || !b || typeof a != 'object' || typeof b != 'object')\n    return a !== a && b !== b\n\n  const arrA = isArray(a)\n  const arrB = isArray(b)\n  let i\n  let length\n  let key\n\n  // If both are arrays\n  if (arrA && arrB) {\n    length = a.length\n    // If unequal length, then not equal\n    if (length != b.length) return false\n    // Loop the arrays and check the contents of both\n    for (i = length; i-- !== 0;)\n      if (!deepEqual(a[i], b[i])) return false\n\n    return true\n  }\n\n  // If on is an array and the other is not, then return false\n  if (arrA != arrB) return false\n\n  // Validate date objects\n  const dateA = a instanceof Date\n  const dateB = b instanceof Date\n  if (dateA != dateB) return false\n  if (dateA && dateB) return a.getTime() == b.getTime()\n\n  // Validate RegExp objects\n  const regexpA = a instanceof RegExp\n  const regexpB = b instanceof RegExp\n  if (regexpA != regexpB) return false\n  if (regexpA && regexpB) return a.toString() == b.toString()\n\n  // Cache the keys and length for faster iteration\n  const keys = keyList(a)\n  length = keys.length\n\n  // If unequal key length then return false\n  if (length !== keyList(b).length) return false\n\n  // Ensure both objects have the same keys\n  for (i = length; i-- !== 0;)\n    if (!hasProp.call(b, keys[i])) return false\n\n  // Check the value of the object keys\n  for (i = length; i-- !== 0;) {\n    key = keys[i]\n    if (!deepEqual(a[key], b[key])) return false\n  }\n\n  return true\n\n}","/** @module collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { cloneFunc } from '../method/cloneFunc'\nimport { isArr } from '../array/isArr'\n\n/**\n * Recursively clones an object or array.\n  * @example\n * const test = { foo: [ { bar: 'baz' } ] }\n * const clone = deepClone(test)\n * console.log(test === clone)) // prints false\n * console.log(test.foo === clone.foo) // prints false\n * @example\n * // Works with array too\n * deepClone([ [ [ 0 ] ] ])\n * // Returns copy of the passed in collection item\n * @function\n * @param {Object} obj - object to clone\n * @return {Object} - cloned Object\n */\nexport const deepClone = (obj, hash = new WeakMap()) => {\n  if (Object(obj) !== obj) return obj\n  if (obj instanceof Set) return new Set(obj)\n  if (hash.has(obj)) return hash.get(obj)\n  if (isArr(obj)) return obj.map(x => deepClone(x))\n  if (isFunc(obj)) return cloneFunc(obj)\n\n  const result = obj instanceof Date \n    ? new Date(obj)\n    : obj instanceof RegExp \n      ? new RegExp(obj.source, obj.flags)\n      : (!obj.constructor)\n        ? Object.create(null)\n        : null\n  \n  // if result is null, object has a constructor and wasn't an instance of Date nor RegExp\n  if (result === null) return cloneObjWithPrototypeAndProperties(obj)\n\n  hash.set(obj, result)\n\n  if (obj instanceof Map)\n    return Array.from(obj, ([key, val]) => result.set(key, deepClone(val, hash)) )\n\n  return Object\n    .assign(\n      result,\n      ...Object.keys(obj)\n        .map(key => ({ [key]: deepClone(obj[key], hash) }))\n    )\n}\n\n/**\n * Helper for deepClone. Deeply clones the object, including its properties, and preserves the prototype and isFrozen and isSealed state\n * @function\n * @ignore\n * @param {Object} objectWithPrototype - any object that has a prototype\n * @returns {Object} the cloned object \n */\nexport const cloneObjWithPrototypeAndProperties = (objectWithPrototype) => {\n\n  if (!objectWithPrototype) return objectWithPrototype\n\n  const prototype = Object.getPrototypeOf(objectWithPrototype)\n  const sourceDescriptors = Object.getOwnPropertyDescriptors(objectWithPrototype)\n\n  for (const [key, descriptor] of Object.entries(sourceDescriptors)) {\n    descriptor.value &&\n      ( sourceDescriptors[key].value = deepClone(descriptor.value) )\n  }\n\n  const clone = Object.create(prototype, sourceDescriptors)\n\n  if (Object.isFrozen(objectWithPrototype)) Object.freeze(clone)\n  if (Object.isSealed(objectWithPrototype)) Object.seal(clone)\n\n  return clone \n}\n","/** @module Helpers */\n\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\nimport { toNum } from '../number/toNum'\nimport { isStrBool } from '../boolean/isStrBool'\nimport { toBool } from '../boolean/toBool'\n\n/**\n * Converts a string to its own type if possible.\n * @example\n * strToType('12345678')\n * // Returns 12345678\n * @example\n * strToType('{}')\n * // Returns {}\n * @example\n * strToType('[]')\n * // Returns []\n * @function\n * @param {*} val - value to convert\n * @return { any | string } converted value || string if can't convert\n */\nexport const strToType = val => {\n  return !val || !isStr(val)\n    ? val\n    : isStrBool(val)\n      ? toBool(val)\n      : isNum(val)\n        ? toNum(val)\n        : (() => {\n            try { return JSON.parse(val) }\n            catch(e){ return val }\n          })()\n}","/** @module log */\n\n'use strict'\n\nlet SHOW_LOGS\nlet METH_DEF = 'dir'\nlet PREFIX = 'type'\nconst LOG_TYPES = [\n  'error',\n  'info',\n  'log',\n  'dir',\n  'warn',\n]\nconst isTest = process.env.NODE_ENV === 'test'\n\n/**\n * Turns logs on || off.\n * <br> Set the default log method.\n * <br> Add a prefix to all log message\n * @example\n * setLogs(true, 'dir', '[ DEV MODE ]')\n * @function\n * @param {boolean} log - log values\n * @param {string} methDef - default log method\n * @param {string} prefix - string to add to all logs\n * @return { void }\n */\nexport const setLogs = (log, methDef, prefix) => {\n  SHOW_LOGS = log\n  METH_DEF = methDef || METH_DEF || 'log'\n  PREFIX = prefix || PREFIX || 'type'\n}\n\n/**\n * Resets log settings to default\n * @example\n * resetLogs()\n * // Resets settings set from the `setLogs method`\n * @function\n * @return { void }\n */\nexport const resetLogs = () => {\n  SHOW_LOGS = undefined\n  METH_DEF = 'log'\n  PREFIX = 'type'\n}\n\n/**\n * Logs a string to the inspector, uses the last argument to determine the log type\n * @example\n * logData('data to log', 'error')\n * // Will call console.error('data to log')\n * @function\n * @param {Array} args - to be passed to the log call\n * @return { void }\n */\nexport const logData = (...args) => {\n  if(!args.length) return\n  \n  let type = args.length === 1 ? METH_DEF : args.pop()\n  if(!SHOW_LOGS && type !== 'error') return\n\n  else if(typeof args[0] === 'string'){\n    if(PREFIX === 'type')\n      args[0] = `[ ${type.toUpperCase()} ] ${args[0]}`\n    else if(PREFIX)\n      args[0] = `${PREFIX} ${args[0]}`\n  }\n\n  LOG_TYPES.indexOf(type) !== -1\n    ? console[type](...args)\n    : console[METH_DEF](...args, type)\n}\n\nisTest && (module.exports.getShowLogs = () => SHOW_LOGS)\n","/** @module object */\n\n/**\n * Removes all properties from an object.\n * @function\n * @param {Object} obj - object to remove properties from\n * @param {Array} filter - list of keys to not remove\n * @returns { null }\n */\nexport const clearObj = (obj, filter) => {\n  obj && Object\n    .entries(obj)\n    .map(([key, value]) => {\n      if(filter && filter.indexOf(key) !== -1) return\n      if(typeof value === 'object') clearObj(value)\n      obj[key] = undefined\n      delete obj[key]\n    })\n}\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { cloneFunc } from '../method/cloneFunc'\nimport { isArr } from '../array/isArr'\nimport { isObj } from './isObj'\nimport { deepClone } from '../collection/deepClone'\nimport { isColl } from '../collection/isColl'\n\n/**\n * Deep merges an array of objects together.\n * @function\n * @param {Array} sources - array of objects to join\n * @returns {Object|Array} - merged object or array\n */\nexport const deepMerge = (...sources) => {\n  return sources.reduce((merged, source) => {\n      const srcCopy = deepClone(source)\n      return isArr(srcCopy)\n        // Check if it's array, and join the arrays\n        ? [ ...((isArr(merged) && merged) || []), ...srcCopy ]\n          // Check if it's an object, and loop the properties\n        : isObj(srcCopy)\n          // Loop the entries of the object, and add them to the merged object\n          ? Object.entries(srcCopy)\n            .reduce((joined, [ key, value ]) => ({\n              ...joined,\n              // Check it's a function, and if so, clone it\n              [key]: isFunc(value)\n                ? cloneFunc(value)\n                // Check if the value is an object of if key is in the object\n                : isColl(value) && key in joined\n                  // Set to value or deepMerge the object with the current merged object\n                  ? deepMerge(joined[key], value)\n                  // Otherwise just clone and set the value\n                  : deepClone(value)\n            // Pass in merged at the joined object\n            }), merged)\n          // If it's not an array or object, just return the merge object\n          : merged\n  // Check the first source to decide what to merged value should start as\n  }, (isArr(sources[0]) && [] || {}))\n}\n","/** @module object */\n\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if the input is a valid entry - a 2-element array, like what Object.entries produces.\n * Expects the first element in the entry to be either a string or a number.\n * @function\n * @example isEntry([1, 2]) // true\n * @example isEntry([\"id\", 87]) // true\n * @example isEntry([new Date(), 2]) // false, first element not string or number\n * @example isEntry([1, 2, 3]) // false, too many elements\n * @param {any} maybeEntry - Item to check if it's an entry\n *\n * @returns true if it is an entry, false otherwise\n */\nexport const isEntry = (maybeEntry) => isArr(maybeEntry) \n  && (maybeEntry.length === 2)\n  && (isNum(maybeEntry[0]) || isStr(maybeEntry[0]))\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { set } from '../collection/set'\nimport { isArr } from '../array/isArr'\nimport { isObj } from './isObj'\nimport { isEntry } from './isEntry'\n\n/**\n * Returns a new object, each entry of which is the result of applying the cb function to input's corresponding entry \n * @param {Object | Array} obj - regular object or array\n * @param {Function} cb  - function of form: (key, value) => [nextKey, nextValue]\n *  - the return type here is an array of two elements, key and value, where `key` must be either a string or a number\n *  - if a cb does not return an entry, then the original [key, value] pair that was passed into cb will be used instead\n * @example mapObj({a: 2, b: 3}, (k, v) => [k, v * v]) returns: {a: 4, b: 9}\n * @example mapObj({a: 1}, (k, v) => ['b', v]) returns: {b: 1}\n * @function\n *\n * @returns new object with mapping applied, or the original obj if input was invalid\n */\nexport const mapEntries = (obj, cb) => {\n  if (!isArr(obj) && !isObj(obj)) {\n    console.error(obj, `Expected array or object for obj. Found ${typeof obj}`)\n    return obj\n  }\n\n  if (!isFunc(cb)) {\n    console.error(`Expected function for cb. Found ${typeof cb}`)\n    return obj\n  }\n\n  const entries = Object.entries(obj)\n\n  const initialValue = isArr(obj) ? [] : {}\n\n  return entries.reduce(\n    (obj, [key, value]) => {\n      const result = cb(key, value)\n      if (!isEntry(result)) {\n        console.error(`Callback function must return entry. Found: ${result}. Using current entry instead.`)\n        return set(obj, key, value)\n      } \n      return set(obj, result[0], result[1])\n    },\n    initialValue\n  )\n}","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { isObj } from './isObj'\n\n/**\n * Loop over and objects props and values and reduce to new object.\n * @function\n * @param {Object} obj\n * @return {Object} - updated object\n */\nexport const reduceObj = (obj, cb, start={}) => (\n  (isObj(obj) && isFunc(cb) &&\n  Object\n    .entries(obj)\n    .reduce((data, [ key, value ]) => cb(key, value, data), start)\n  ) || start\n)\n","/** @module promise */\n\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Converts a standard callback method into Promise\n * @param {function} method - method to turn into a promise\n * @function\n *\n * @return method as a promise\n */\nexport const promisify = method => {\n  if(!isFunc(method)) throw `Argument must be a function`\n\n  return (...args) => {\n    return new Promise((res, rej) => {\n      // If the last arg is not a function, just return the resolved method\n      if(!isFunc(args[args.length -1]))\n        return res(method(...args))\n\n      // Remove the callback method\n      args.pop()\n      // Replace it with the promise resolve / reject\n      args.push((...cbData) => {\n        // If the cbData first arg is not falsy, then reject the promise\n        // Otherwise resolve it\n        return cbData && cbData[0]\n          ? rej(...cbData)\n          : res(...cbData)\n      })\n\n      // Call the method, and return it\n      return method(...args)\n    })\n  }\n}\n","/** @module promise */\n\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\nimport { promisify } from './promisify'\n\n/**\n * Creates an array of Object default properties not to convert into promises\n * @ignore\n */\nconst defObjProps = Array\n  .from([\n    'caller',\n    'callee',\n    'arguments',\n    'apply',\n    'bind',\n    'call',\n    'toString',\n    '__proto__',\n    '__defineGetter__',\n    '__defineSetter__',\n    'hasOwnProperty',\n    '__lookupGetter__',\n    '__lookupSetter__',\n    'isPrototypeOf',\n    'propertyIsEnumerable',\n    'valueOf',\n    'toLocaleString'\n  ])\n  .concat(Object.getOwnPropertyNames(Object.prototype))\n  .reduce((map, functionName) => {\n    map[functionName] = true\n    return map\n  }, {})\n\n/**\n * Loops an object and looks for any methods that belong to the object, then add an Async version\n * @memberof promise\n * @param {Object} object\n * @return {Object} - object with Async methods added\n */\nconst addAsync = object => {\n  if (!object.__IS_PROMISIFIED__) {\n    for (const prop of Object.getOwnPropertyNames(object)) {\n      const isAsync = prop.indexOf('Async') !== -1 || object[`${prop}Async`]\n      if (isAsync || defObjProps[prop]) continue\n\n      if(isFunc(object[prop]))\n        object[`${prop}Async`] = promisify(object[prop])\n      else {\n        const getValue = Object.getOwnPropertyDescriptor(object, prop).get\n        if(isFunc(getValue)) object[`${prop}Async`] = promisify(getValue)\n      }\n    }\n    object.__IS_PROMISIFIED__ = true\n  }\n\n  return object\n}\n\n/**\n * Converts Objects method properties into promiseAsync. allow using promisifyAll\n * @function\n * @param {Object} object\n * @return {Object} - promisified object\n */\nexport const promisifyAll = object => {\n  if(!isObj(object)) return object\n\n  addAsync(object)\n  const proto = Object.getPrototypeOf(object)\n\n  proto &&\n    Object.getPrototypeOf(proto) !== null &&\n    addAsync(proto)\n\n  return object\n}\n","/** @module url */\n\nimport { isArr } from '../array/isArr'\n\n/**\n * takes a raw querystring input and converts it to an object\n * @param {String} string - querystring to parse into an object\n * @function\n * @returns {Object}\n */\nexport const queryToObj = string => {\n\n  const currentQueryItems = {}\n  const stringSplit = string.split('?')\n  const querystring = stringSplit[ stringSplit.length -1 ]\n  \n  if(!querystring) return currentQueryItems\n\n  const split = querystring.split('&')\n\n  split.length &&\n    split.map(item => {\n\n      const components = item.split('=')\n      if (components.length <= 1) return currentQueryItems\n\n      // split on the first instance of '=', so we join the rest if any\n      const itemSplit = [components.shift(), components.join('=')]\n\n      if (itemSplit.length === 2) {\n        \n        // if the value contains special char ',' then make it into an array\n        const array = decodeURIComponent(itemSplit[1]).split(',')\n        if (array && array.length > 1)\n          currentQueryItems[itemSplit[0]] = array\n        \n        // check if key already exists\n        else if (itemSplit[0] in currentQueryItems) {\n           // convert to array or append to it\n           const val = currentQueryItems[itemSplit[0]]\n           currentQueryItems[itemSplit[0]] = isArr(val) \n             ? val.push(decodeURIComponent(itemSplit[1])) \n             : [val, decodeURIComponent(itemSplit[1])]        \n        }\n        else\n          currentQueryItems[itemSplit[0]] = decodeURIComponent(itemSplit[1])\n      }\n    })\n\n  return currentQueryItems\n}\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { deepClone } from '../collection/deepClone'\nimport { isObj } from './isObj'\n\n/**\n * Deep clones Object obj, then returns the result of calling function mutatorCb with the clone as its argument\n * @example\n * const obj = {}\n * const clone = applyToCloneOf(obj, (clone) => { clone.test = 'foo'; return clone })\n * console.log(obj === clone) // prints false\n * console.log(clone.test === 'foo') // prints true\n * @function\n * @param {Object} obj - object\n * @param {Function} mutatorCb - a callback that accepts one argument, the cloned obj, and mutates it in some way\n * @returns the mutated clone\n */\nexport const applyToCloneOf = (obj, mutatorCb) => {\n  let error\n  if (!obj) error = 'object (Argument 1) in applyToCloneOf, must be defined!'\n\n  if (!isObj(obj)) error = 'object (Argument 1) in applyToCloneOf, must be an object!'\n\n  if (!mutatorCb) error = 'mutator (Argument 2) in applyToCloneOf, must be defined!'\n\n  if (!isFunc(mutatorCb)) error = 'mutator (Argument 2) arg in applyToCloneOf, must be a function!'\n  \n  if(error) return console.warn(error) || obj\n\n  const clone = deepClone(obj)\n  mutatorCb(clone)\n\n  return clone\n}\n","/** @module array */\n\nimport { validate } from '../validation'\nimport { isArr } from './isArr'\n\n/**\n * Checks if arrays are set-equal: they contain the same elements,\n * but element frequencies don't matter.\n * Does this with one pass over each array and an auxilliary set.\n * @function\n * @param {Array<*>} arr \n * @param {Array<*>} otherArr \n */\nexport const areSetEqual = (arr, otherArr) => {\n  const [ valid ] = validate({ arr, otherArr }, { $default: isArr })\n  if (!valid) return null\n\n  if (arr === otherArr) return true\n\n  const [ longest, shortest ] = arr.length > otherArr.length\n    ? [ arr, otherArr ]\n    : [ otherArr, arr ]\n\n  const arrSet = new Set(shortest)\n\n  for (let i = 0; i < longest.length; i++) {\n    const element = longest[i]\n    if (!arrSet.has(element)) return false\n  }\n\n  return true\n}","/** @module string */\n\n/**\n * Builds a string path from passed in args ( i.e. path/to/thing ).\n * @function\n * @return {string} - built path from arguments\n */\nexport const buildPath = (...args) => {\n  const built = args.reduce((path, arg) => {\n    let str = toStr(arg)\n\n    return `${path}${ str && '/' + str || '' }`\n  }, '')\n  \n  return built.replace(/([^:\\/]|^)\\/{2,}/g, '$1/')\n}\n","import { capitalize } from './capitalize'\n\n/**\n * Turns a path string into a camel-cased string, if there is more than one\n * step in the path. If there isn't, just returns path.\n * @param {string} path \n * @return {string} camel-cased string\n * @example\n * camelCasePath('settings.agendaMap.Count') -> 'settingsAgendaMapCount'\n * camelCasePath('settings') -> 'settings'\n */\nexport const camelCasePath = (path) => {\n  const split = path.split('.')\n  const camelCasedSplit = split.map(\n    (str, idx) => idx > 0\n      ? capitalize(str, false)\n      : str\n  )\n\n  return camelCasedSplit.length > 1 \n    ? camelCasedSplit.join('')\n    : path\n}\n","/** @module functions */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Check if the passed in method is a function, and calls it\n * @example\n * checkCall((param1) => { return param1 }, 'foo')\n * // Returns 'foo'\n * @function\n * @param {function} method - function to call\n * @param {Object} params - params to pass to the method on call\n * @return {*} - whatever the passed in method returns\n */\nexport const checkCall = (method, ...params) =>  isFunc(method) && method(...params) || undefined\n","/** @module array */\n\nimport { isArr } from './isArr'\nimport { isObj } from '../object/isObj'\n\n/**\n * Creates a copy of the passed in array.\n * <br> Returns empty array, if param is not an array.\n * @function\n * @example\n * cloneArr([1,2,3])\n * // Returns copy of the passed on array\n * @param {array} arr - array to be copied\n * @return {array} - copy of passed in array\n */\nexport const cloneArr = arr => (\n  Array.from([\n    // If arr is not an array or object, just use empty array, so we don't throw!\n    ...(isArr(arr) && arr || isObj(arr) && Object.entries(arr) || [])\n  ])\n)\n","/** @module object */\n\nimport { logData } from '../log'\n\n/**\n * Clones an object by converting to JSON string and back.\n * @function\n * @param {Object} obj - object to clone\n * @returns {Object} copy of original object\n */\nexport const cloneJson = obj => {\n  try {\n    return JSON.parse(JSON.stringify(obj))\n  }\n  catch(e){\n    logData(e.message, 'error')\n    return null\n  }\n}\n","/** @module functions */\n\nimport { validate } from '../validation'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Returns a new function that is the complement of predicate function `predicate`\n * @function\n * @param {Function} predicate \n * @returns {Function?} the complement of `predicate`, if it's a function, otherwise null\n * @example\n * const isNegative = x => (x < 0)\n * const isNonNegative = complement(isNegative)\n * isNonNegative(1) // true\n */\nexport const complement = predicate => {\n  const [ valid ] = validate({ predicate }, { predicate: isFunc })\n  return valid\n    ? (...args) => !predicate(...args)\n    : null\n}","/** @module string */\n\nimport { isStr } from './isStr'\nimport { toStr } from './toStr'\n\n\n/**\n * Checks if a string contains another string.\n * @function\n * @param {string} string - value to be checked\n * @param {string} substring - value to search for\n * @return {boolean} - if the substring exists string\n */\nexport const containsStr = (str, substring, fromIndex) => {\n  str = !isStr(str) && toStr(str) || str\n  substring = !isStr(substring) && toStr(substring) || substring\n\n  return str.indexOf(substring, fromIndex) !== -1;\n}\n","/** @module functions */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Limits the amount of calls to a function over time\n * @example\n * debounce(myFunction)\n * // Calls myFunction after the default 250 ms\n * @example\n * debounce(myFunction, 500)\n * // Calls myFunction after 500 ms\n * @example\n * debounce(myFunction, 500, true)\n * // Calls myFunction immediately\n * @function\n * @param {function} func - function to call\n * @param {number} wait - how long to wait between function calls\n * @param {boolean} immediate - should call immediately\n * @return { void }\n */\nexport const debounce = (func, wait = 250, immediate = false) => {\n  let timeout\n  function wrapFunc(...args){\n    if (!isFunc(func)) return null\n\n    const context = this\n    const later = () => {\n      timeout = null\n      !immediate && func.apply(context, args)\n    }\n    const callNow = immediate && !timeout\n    clearTimeout(timeout)\n    timeout = setTimeout(later, wait)\n    if (callNow)\n      return isFunc(func) && func.apply(context, args)\n  }\n  return wrapFunc\n}\n","/** @module functions */\n\nimport { isNum } from '../number/isNum'\nimport { isFunc } from './isFunc'\n\n/**\n * Execute a method n times.\n * <br> Callback params - does not include number || callback method\n * @function\n  * @example\n * doIt(10, window, [], (index, arr) => { arr.push(index) }) === [ 0,1,2 ... 8,9 ]\n * @param {number} args.0 - number of times to call the callback\n * @param {parent} args.1 - value to bind the method call to ( this )\n * @param {function} last arg of args array - method to call\n * @return { void }\n */\nexport const doIt = (...args) => {\n  const params = args.slice()\n  const num = params.shift()\n  const bindTo = params.shift()\n  const cb = params.pop()\n  if(!isNum(num) || !isFunc(cb)) return []\n  \n  const doItAmount = new Array(num)\n  const responses = []\n  for(let i = 0; i < doItAmount.length; i++){\n    const data = cb.call(bindTo, i, ...params)\n    if (data === false) break\n    responses.push(data)\n  }\n\n  return responses\n}\n","/** @module Helpers */\n\nimport { softFalsy } from '../boolean/softFalsy'\nimport { isFunc } from '../method/isFunc'\n\n\n/**\n * Determines the correct value to return, by calling the passed in check function.\n * <br> If no check function, then it uses the softFalsy method.\n * @example\n * either(0, 2)\n * // Returns 0\n * @example\n * either(null, 2)\n * // Returns 2\n * @example\n * either(1, 2, (val1, val2) => { return true })\n * // Returns 1\n * @function\n * @param {*} val1 - return if passes in check method return true\n * @param {*} val2 - return if passed in check method returns false\n * @param {function} function - called to determine which value to return\n * @returns {*}\n */\nexport const either = (val1, val2, check) => (\n  !isFunc(check)\n    ? softFalsy(val1) && val1 || val2\n    : check(val1, val2) && val1 || val2\n)\n","/** @module array */\n\nimport { isArr } from './isArr'\n\n/**\n * Returns a if it is an Array, else returns b\n * @function\n * @param {*} a\n * @param {*} b\n * @returns {*} either a, if it's an array, or b\n * \n * @example\n * const foo = eitherArr('hi', 1) // returns 1\n * const bar = eitherArr([ 2 ], 1) // returns [ 2 ]\n */\nexport const eitherArr = (a, b) => isArr(a) ? a : b","/** @module functions */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Returns the first param if it's a function.\n * <br> If first param is not a function, returns second param.\n * @example\n * eitherFunc(() => {}, 'bar')\n * // Returns first param because it's a function.\n * @example\n * eitherFunc('foo', 'bar')\n * // Returns 'bar'\n * @function\n * @param {function} func1 - return if is func\n * @param {function} func2 - use if first is not an object\n * @returns {function}\n */\nexport const eitherFunc = (func1, func2) => (\n  isFunc(func1) && func1 || func2\n)\n","/** @module object */\n\nimport { isObj } from './isObj'\n\n/**\n * Returns the first param if correct type of second param.\n * @function\n * @param {Object} obj1 - return if is object\n * @param {Object} obj2 - use if first is not an object\n * @returns {Object}\n */\nexport const eitherObj = (obj1, obj2) => (\n  isObj(obj1) && obj1 || obj2\n)\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Checks if the first param is a string, and returns it.\n * <br> If it's not a string, the second param is returned\n * @function\n * @param {string} str1 - return if is string\n * @param {string} str2 - use if first is not a string\n * @returns {string}\n */\nexport const eitherStr = (str1, str2) => (\n  isStr(str1) && str1 || str2\n)\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { pipeline } from '../method/pipeline'\nimport { isObj } from './isObj'\n\n/**\n * Like \"every\" for arrays, but operates across each entry in obj\n * @function\n * @param {Object} obj \n * @param {Function} predicate of form (key, value) => boolean. Returns true or false for the entry\n * @returns boolean indicating that every entry satisfied the predicate or not\n */\nexport const everyEntry = (obj, predicate) => {\n  if (!obj) {\n    console.error(`everyEntry expects argument obj [${obj}] to be defined.`)\n    return false\n  }\n\n  if (!isObj(obj)) {\n    console.error(`Argument obj ${obj} must be an object.`)\n    return false\n  }\n\n  if (!isFunc(predicate)) {\n    console.error(`Argument 'predicate' passed into everyEntry must a function. Found: ${predicate}`)\n    return false\n  }\n\n  return pipeline(\n    obj,\n    Object.entries,\n    entries => entries.every(([key, value]) => predicate(key, value))\n  )\n}\n","/** @module Helpers */\n\n/**\n * Checks if a value exists. NOT undefined || null\n * @function\n * @example\n * exists(0)\n * // Returns true\n * @example\n * exists(null)\n * // Returns false\n * exists('')\n * // Returns true\n * exists(NaN)\n * // Returns false\n * @param {*} value - Item to check if exists\n *\n * @returns {boolean} - If the item exists or not\n */\nexport const exists = value => value === value && value !== undefined && value !== null\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { isObj } from './isObj'\nimport { reduceObj } from './reduceObj'\n\n/**\n * Returns a new object, consisting of every key-value pair from obj that, when passed into the predicate, returned true\n * @function\n * @param {*} obj - regular object\n * @param {*} predicate  - function of form: (key, value) => Boolean\n * @returns object consisting of a subset of the entries from obj\n * @example: filterObj({a: 2, b: 3}, (k, v) => (v > 2)) returns: {b: 3}\n */\nexport const filterObj = (obj, predicate) => {\n  if (!obj) return obj\n\n  if (!isObj(obj)) {\n    console.error(`Object ${obj} was not an object. It must be for filterObject`)\n    return obj\n  }\n\n  if (!isFunc(predicate)) {\n    console.error(`Argument 'predicate' passed into filterObject must a function. Found: ${predicate}`)\n    return obj\n  } \n\n  return reduceObj(\n    obj,\n    (key, value, data) => {\n      if (predicate(key, value))\n        data[key] = value\n      return data\n    },\n    {}\n  )\n}\n","/** @module array */\nimport { identity, compareTo } from '../method'\nimport { findExtrema } from './findExtrema'\n\n/**\n * Returns the maximum element in arr\n * @function\n * @param {Array<Object>} arr\n * @param {Function?} propSelector - optional property selector for choosing the property to compare with\n * @example\n * const items = [ { num: 1 }, { num: 3 } ]\n * findMax(items, item => item.num) // returns { num: 3 }\n */\nexport const findMax = (arr = [], propSelector=identity) => findExtrema(\n  arr, \n  (x, y) => compareTo(propSelector(x), propSelector(y))\n)\n","/** @module array */\nimport { identity, compareTo } from '../method'\nimport { findExtrema } from './findExtrema'\n\n/**\n * Returns the minimum element in arr\n * @function\n * @param {Array<Object>} arr\n * @param {Function?} propSelector - optional property selector for choosing the property to compare with\n * @example\n * const items = [ { num: 1 }, { num: 3 } ]\n * findMax(items, item => item.num) // returns { num: 1 }\n */\nexport const findMin = (arr = [], propSelector=identity) => findExtrema(\n  arr, \n  (x, y) => compareTo(propSelector(y), propSelector(x))\n)\n","/** @module array */\n\nimport { isArr } from './isArr'\nimport { isFunc } from '../method/isFunc'\nimport { validate } from '../validation'\n\n/**\n * Maps each element using mapping function `mapFn`, but returns the result as a flattened array.\n * It is equivalent to map() followed by flattening to depth 1, but flatMap is a useful shortcut,\n * and merging both steps into one method (with one pass over the array) is slightly more efficient. \n * @function\n * @example\n * [1, 2].map(x => [x * 2]) // returns [[2], [4]]\n * flatMap([1, 2], x => [x * 2]) // returns [2, 4]\n * @param {Array} arr - array to map across\n * @param {Function} mapFn - function for mapping\n */\nexport const flatMap = (arr, mapFn) => {\n  const [ inputIsValid ] = validate(\n    { arr, mapFn },\n    { arr: isArr, mapFn: isFunc }\n  )\n  if (!inputIsValid) return arr;\n\n  // iterate across the array, calling mapFn on each element, then flattening into final array\n  return arr.reduce(\n    (finalArr, current) => {\n      const result = mapFn(current)\n      isArr(result)\n        ? result.map(el => finalArr.push(el))\n        : finalArr.push(result)\n      return finalArr\n    },\n    []\n  )\n}\n\n","/** @module url */\n\nimport { queryToObj } from './queryToObj'\nimport { validate } from '../validation/validate'\nimport { isStr } from '../string/isStr'\n\n/**\n * Gets the value for the URL parameter, if it's available.\n * Can be safely called on platforms without a global document object,\n * in which case this always returns null.\n * @function\n * @param {string} paramKey - a url param key \n * @return {string?} - value for the url parameter\n * @example\n * for www.test.com/?x=1&y=2\n * getURLParam('x') // 1\n * getURLParam('y') // 2\n */\nexport const getURLParam = paramKey => {\n  const [ valid ] = validate({ paramKey }, { paramKey: isStr })\n  if (!valid) return null\n\n  const doc = typeof document !== 'undefined' \n    ? document \n    : null\n  \n  const search = doc?.location?.search\n\n  return isStr(search)\n    ? queryToObj(search)?.[paramKey] ?? null\n    : null \n}","import { isObj } from './isObj'\nimport { isArr } from '../array/isArr'\nimport { toBool } from '../boolean/toBool'\n\n/**\n * Returns true if the input is an object and every\n * value is an array\n * @param {*} obj - data to check\n * @return {boolean} true if input is an array map\n */\nexport const isArrMap = obj => {\n  if (!isObj(obj)) return false\n  const values = Object.values(obj)\n  return toBool(\n    values.length && values.every(isArr)\n  )\n}","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a email.\n * @function\n * @param {string} string to check\n * @return {boolean} - if it's a email\n */\nexport const isEmail = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^\\w+([.-]?\\w+)*@\\w+([.-]?\\w+)*(\\.\\w{2,3})+$/\n  return Boolean(regex.test(str))\n}\n","/** @module Helpers */\n\nimport { isObj } from '../object/isObj'\nimport { isArr } from '../array/isArr'\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\n\n/**\n * Checks if the value is empty.\n * @example\n * isEmpty('')\n * // Returns true\n * @example\n * isEmpty({})\n * // Returns true\n * @example\n * isEmpty([ 1 ])\n * // Returns false\n * @function\n * @param { object | array | number | string } val - value to check\n * @return {boolean} if the value is empty\n */\nexport const isEmpty = val => (\n  isObj(val)\n    ? Object.keys(val).length === 0\n    : isArr(val)\n      ? val.length === 0\n      : isStr(val)\n        ? val.trim().length === 0\n        : isNum(val)\n          ? val < 1\n          : false\n)\n","/** @module collection */\n\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Checks if passed in obj || array is empty.\n * @example\n * isEmptyColl({})\n * // Returns true\n * @example\n * isEmptyColl({ foo: 'bar' })\n * // Returns false\n * @example\n * isEmptyColl([])\n * // Returns true\n * @function\n * @param {Object} obj - object to check if empty\n * @return {boolean}  true || false\n */\nexport const isEmptyColl = obj => (\n  isArr(obj)\n    ? obj.length === 0\n    : isColl(obj) && Object.getOwnPropertyNames(obj).length === 0\n)\n","/** @module number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is a Float.\n * @example\n * isFloat(1.23)\n * // Returns true\n * @example\n * isFloat('1.2')\n * // Returns false ( because it's a string )\n * @function\n * @param {number} num - value to check\n * @return {boolean} true or false - value is an Float\n */\nexport const isFloat = val => (\n  isNum(val) && val % 1 !== 0\n)\n","/** @module number */\n\nimport { isNum } from './isNum'\n\n/**\n * Checks if a number is an integer.\n * @example\n * isInt(1)\n * // Returns true\n * @example\n * isInt('1')\n * // Returns false ( because it's a string )\n * @function\n * @param {number} num - value to check\n * @return {boolean} true or false - value is an Int\n */\nexport const isInt = val => (\n  isNum(val) && (val % 1 === 0)\n)\n","/** @module number */\n\nimport { isNum  } from \"./isNum\"\n\n/**\n * @function\n * @param {*} x \n * @returns { boolean } true if x is a negative number\n * @example isNegative(-1) // true\n * @example isNegative(0) // false\n */\nexport const isNegative = x => isNum(x) && (x < 0)","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a phone number.\n * @function\n * @param {string} string to check\n * @return {boolean} - if it's a phone number\n */\nexport const isPhone = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/im\n  return Boolean(regex.test(str)) && str.replace(/\\D/g, '').length < 11\n}\n","/** @module number */\n\nimport { isNum } from './isNum'\n\n/**\n * @function\n * @param {*} x \n * @returns { boolean } true if x is a positive number\n * @example isPositive(0) // false\n * @example isPositive(1) // true\n */\nexport const isPositive = x => isNum(x) && (x > 0)","/** @module Helpers */\n\n/**\n * Checks if the passed in values are exactly the same.\n * @example\n * isSame(1, 1)\n * // Returns true\n * @function\n * @param {*} val1 - value to compare\n * @param {*} val2 - value to compare\n * @return {boolean} is the values are the same\n */\nexport const isSame = (val1, val2) => (\n  val1 === val2\n    ? val1 !== 0 || 1 / val1 === 1 / val2\n    : val1 !== val1 && val2 !== val2\n)\n","/** @module string */\n\n/**\n * Check if string is a url.\n * @function\n * @param {string} string to check\n * @return {boolean} - if it's a url\n */\nexport const isUrl = str => {\n  const regex = /^(?:(?:https?|ftp):\\/\\/)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:\\/\\S*)?$/\n  return Boolean(regex.test(str))\n}\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Check if string is a uuid.\n * @function\n * @param {string} string to check\n * @return {boolean} - if it's a uuid\n */\nexport const isUuid = str => {\n  if (!str || !isStr(str)) return false\n  const regex = /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i\n  return Boolean(regex.test(str))\n}\n","/** @module Helpers */\n\n/**\n * Checks is passed in date is a valid date.\n * @example\n * isValidDate(new Date())\n * // Returns true\n * @example\n * isValidDate(new Date().toString())\n * // Returns true\n * @example\n * isValidDate('12345678')\n * // Returns false\n * @function\n * @param { date | string } date - value to check\n * @return {boolean} T/F - if passed in date is a valid date\n */\nexport const isValidDate = date => (\n  !isNaN( (date instanceof Date && date || new Date(date)).getTime() )\n)\n","/** @module url */\n\n/**\n * Checks if the given string is a valid URL\n * Must begin with ftp/http/https\n * @param {String} string - any string to check if it's a valid url\n * @function\n * @returns {Boolean}\n */\nexport const isValidUrl = string => {\n  var regexp = /(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-/]))?/\n\n  return regexp.test(string)\n}\n","/** @module object */\n\n/**\n * Compares two objects by converting to JSON, and checking string equality.\n * @function\n * @param { object | array } one - object to compare with param two\n * @param { object | array } two - object to compare with param one\n * @return {boolean} status of equality\n */\nexport const jsonEqual = (one, two) => {\n  try {\n    return JSON.stringify(one) === JSON.stringify(two)\n  }\n  catch(e){\n    return false\n  }\n}\n","/** @module object */\n\nimport { isStr } from '../string/isStr'\nimport { isArr } from '../array/isArr'\n\n/**\n * Converts an array of strings to a matching key/value pair object.\n * @function\n * @param {Array} arr - to be converted to object\n * @param {string} toUpperCase - converts the key and value to uppercase\n * @return {Object} built object\n */\nexport const keyMap = (arr, toUpperCase) => (\n  isArr(arr) && arr.reduce((obj, key) => {\n    if(!isStr(key)) return obj\n    \n    const use = toUpperCase && key.toUpperCase() || key\n    obj[use] = use\n\n    return obj\n  }, {}) || {}\n)","/** @module functions */\n\nimport { isFunc } from './isFunc'\n\n/**\n * Adds catch to a promise for better error handling of await functions\n * <br> Removes the need for wrapping await in a try / catch\n * @example\n * const [ err, data ] = await limbo(promiseFunction())\n * // returns an array\n * // * err will be undefined if no error was thrown\n * // * data will be the response from the promiseFunction\n * @function\n * @param {Promise} promise - Promise to be resolved\n * @return {Array} - Slot 1 => error, Slot 2 => response from promise\n */\nexport const limbo = promise => {\n  return !promise || !isFunc(promise.then)\n    ? [ new Error(`A promise or thenable is required as the first argument!`), null]\n    : promise\n      .then(data => [null, data])\n      .catch(err => [err, undefined])\n}\n","/** @module collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Loops over a collection and calls a passed in function for each one.\n * @example\n * mapColl([1, 2, 3], (key, val, coll) => { console.log(key) })\n * // Will log all keys of the collection\n * @function\n * @param {Array|Object} - collection to loop over\n * @return {Array|Object} returns the same type of collection passed in\n */\nexport const mapColl = (coll, cb) => (\n  isFunc(cb) && isColl(coll)\n    ? Object\n      .keys(coll)\n      .map(key => cb(key, coll[key], coll))\n    : isArr(coll)\n      ? []\n      : {}\n)\n","/** @module object */\n\n\nimport { isObj } from './isObj'\nimport { isFunc } from '../method/isFunc'\nimport { mapEntries } from './mapEntries'\n\n/**\n * Shortcut helper for mapping just the keys of an object.\n * @function\n * @param {Object} obj \n * @param {Function} keyMapper: (key) => nextKey\n * @returns the new object with each key mapped\n */\nexport const mapKeys = (obj, keyMapper) => {\n  if (!isObj(obj) || !isFunc(keyMapper)) \n    return obj\n\n  return mapEntries(\n    obj,\n    (key, value) => [keyMapper(key), value]\n  )\n}\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { isObj } from './isObj'\n\n/**\n * Map over and objects props and values.\n * @function\n * @param {Object} obj\n * @return {Array} -  returned values from callback\n */\nexport const mapObj = (obj, cb) => (\n  (isObj(obj) && isFunc(cb) &&\n  Object\n    .entries(obj)\n    .map(([ key, value ]) => cb(key, value))\n  ) || obj\n)\n","/** @module functions */\n\nimport { isNum } from '../number/isNum'\nimport { hasOwn } from '../object/hasOwn'\nimport { isFunc } from './isFunc'\n\n/**\n * Creates a method to memorize passed in methods output\n * @example\n * memorize(myFunction, cacheKeyFunction)\n  * @example\n * memorize(myFunction, cacheKeyFunction, 100)\n * @function\n * @param {function} func - method to memorize output of\n * @param {function} getCacheKey - gets the key to save cached output\n *\n * @return {function} memorized function with cache\n */\nexport const memorize = (func, getCacheKey, limit=1) => {\n    if (!isFunc(func) || (getCacheKey && !isFunc(getCacheKey)))\n      return console.error('Error: Expected a function', func, getCacheKey)\n\n    let memorized = function(){\n      const cache = memorized.cache\n      const key = getCacheKey ? getCacheKey.apply(this,  arguments) : arguments[0]\n\n      if (hasOwn(cache, key)) return cache[key]\n\n      const result = func.apply(this, arguments)\n\n      isNum(limit) && Object.keys(cache).length < limit\n        ? (cache[key] = result)\n        : (memorized.cache = { [key]: result })\n\n      return result\n    }\n\n    memorized.cache = {}\n    memorized.destroy = () => {\n      getCacheKey = undefined\n      memorized.cache = undefined\n      memorized.destroy = undefined\n      memorized = undefined\n    }\n\n    return memorized\n}\n","/** @module number */\n\nimport { equalsNaN } from './equalsNaN'\nimport { isNum } from './isNum'\nimport { getNums } from './getNums'\nimport { toNum } from './toNum'\n\n/**\n * Finds the number ext base on the passed in number.\n * @example\n * nth(1)\n * // Returns 'st'\n * @example\n * nth(2)\n * // Returns 'nd'\n * @example\n * nth(5)\n * // Returns 'th'\n * @function\n * @param {number} num - value to check\n * @return {string} ext of the number\n */\nexport const nth = num => {\n\n  if(!isNum(num)){\n    num = getNums(num)\n    if(!num) return ''\n    num = toNum(num)\n    if(equalsNaN(num)) return ''\n  }\n\n  const mod = (num % 100)\n  if (mod >= 10 && mod <= 20)\n    return 'th'\n\n  switch(num % 10) {\n    case 1:\n      return 'st'\n    case 2:\n      return 'nd'\n    case 3:\n      return 'rd'\n    default:\n      return 'th'\n  }\n}\n","/** @module url */\n\nimport { reduceObj } from '../object/reduceObj'\nimport { isStr } from '../string/isStr'\nimport { isNum } from '../number/isNum'\nimport { isBool } from '../boolean/isBool'\nimport { isColl } from '../collection/isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Converts the input object to url querystring\n * @param {Object} obj - object with kvp to convert into a querystring\n * @function\n * @returns {String} querystring\n */\nexport const objToQuery = obj => {\n  let firstSet\n  return reduceObj(obj, (key, value, urlStr) => {\n    if(!value) return urlStr\n\n    const useVal = isStr(value) || isNum(value) || isBool(value)\n      ? value \n      : isColl(value)\n        ? isArr(value) \n          ? value.join(',') \n          : JSON.stringify(value)\n        : null\n    \n    if(!useVal) return urlStr\n\n    urlStr = !firstSet\n      ? `?${encodeURIComponent(key)}=${encodeURIComponent(useVal)}`\n      : `${urlStr}&${encodeURIComponent(key)}=${encodeURIComponent(useVal)}`\n    firstSet = true\n\n    return urlStr\n  }, '')\n}\n","/** @module object */\n\nimport { isObj } from './isObj'\nimport { reduceObj } from './reduceObj'\n\n/**\n * Creates a new object from passed in object with keys not defined from array.\n * @function\n * @param {Object} target - object to pull keys from\n * @param {Array} keys - keys to not add to new object\n * @return {Object} new object with only keys not in array\n */\nexport const omitKeys = (obj = {}, keys = []) => (\n  isObj(obj) && reduceObj(obj, (key, _, updated) => {\n      keys.indexOf(key) === -1 && (updated[key] = obj[key])\n\n      return updated\n    }, {}) || {}\n)\n","/** @module array */\n\nimport { isNonNegative } from '../number/isNonNegative'\nimport { validate } from '../validation'\nimport { isArr } from './isArr'\n\n/**\n * Returns a new array with the same elements as arr, excluding `count` elements beginning at index `startIndex`\n * @function\n * @param {Array} arr \n * @param {Number} startIndex \n * @param {Number} count \n */\nexport const omitRange = (arr, startIndex, count) => {\n  const [ inputIsValid ] = validate(\n    { arr, startIndex, count },\n    { arr: isArr, $default: isNonNegative }\n  )\n\n  if (!inputIsValid) return arr\n\n  const nextArr = [ ...arr ]\n\n  nextArr.splice(startIndex, count)\n\n  return nextArr\n}\n","/** @module string */\n\n/**\n * Convert JSON string into object, wrapped in a try / catch.\n * @function\n * @param {string} string\n * @return {Object} - JSON object\n */\nexport const parseJSON = str => {\n  try {\n    return JSON.parse(str)\n  }\n  catch (e){\n    console.error(e.message)\n    return null\n  }\n}\n","/** @module object */\n\nimport { isObj } from './isObj'\n\n/**\n * Creates a new object from passed in object with keys defined from array.\n * @function\n * @param {Object} target - object to pull keys from\n * @param {Array} keys - keys to add to new object\n * @return {Object} new object with only keys from passed in keys array\n */\nexport const pickKeys = (obj = {}, keys = []) => (\n  isObj(obj) && keys.reduce((updated, key) => {\n    key in obj && (updated[key] = obj[key])\n\n    return updated\n  }, {}) || {}\n)\n","/** @module string */\n\n/**\n * Adds an `s` to the end of a string, if one does not exist.\n * @function\n * @param {string} str - string to convert\n * @return {string} string as a plural\n */\nexport const plural = str => {\n  if (!str || !str.length) return str\n  return str[str.length - 1] !== 's' ? str + 's' : str\n}\n","/** @module array */\n\nimport { isArr } from './isArr'\n\n/**\n * Randomly selects values from a passed in array.\n * @function\n * @example\n * randomArr([1,2,3], 1)\n * // Returns an array with one of the values in the passed in array\n * @param {array} arr - array to select values from\n * @param {number} amount - number of values to select from the array\n * @return {array} - randomly sorted array\n */\nexport const randomArr = (arr, amount) => {\n  if(!isArr(arr)) return arr\n\n  const useAmount = amount || 1\n  const randoms = []\n  for (let i = 0; i < useAmount; i++) {\n    randoms.push(arr[Math.floor(Math.random() * arr.length)])\n  }\n\n  return !amount ? randoms[0] : randoms\n}\n","/** @module array */\n\nimport { isArr } from './isArr'\n\n/**\n * Randomly sorts an arrays items.\n * @function\n * @example\n * randomizeArr([1,2,3])\n * // Returns an array randomly sorted\n * @param {array} arr - array to randomly sorted\n * @return {array} - randomly sorted array\n */\nexport const randomizeArr = arr => (\n  !isArr(arr) && arr || arr.sort(() => (0.5 - Math.random()))\n)","/** @module collection */\n\nimport { isFunc } from '../method/isFunc'\nimport { isColl } from './isColl'\nimport { isArr } from '../array/isArr'\n\n/**\n * Loops over collection and calls reduce.\n * @example\n * reduceColl([1, 2, 3], (key, val, coll) => { console.log(key) }, {})\n * // Returns what ever is returned from the last iteration of the reduce loop\n * @function\n * @param {Object} obj - object loop over\n * @param {function} path - path that should be created on the object, separated by .\n * @param {*} reduce - starting data passed to reduce method\n * @return {Object} - last returned data from the loop\n */\nexport const reduceColl = (coll, cb, reduce) => (\n  isFunc(cb) && isColl(coll)\n    ? Object\n      .keys(coll)\n      .reduce((data, key) => cb(key, coll[key], coll, data), reduce)\n    : isArr(coll)\n      ? []\n      : {}\n)\n","/** @module collection */\n\nimport { deepClone } from './deepClone'\nimport { isFunc } from '../method/isFunc'\nimport { isNum } from '../number/isNum'\n\n/**\n * Returns an array composed of element repeated \"times\" times. If element is a function, it will be called.\n * <br> Note: if you simply want to run a function some number of times, without returning an array of its results, @see Method.doIt\n * @param {*} element - a value or a function. If it is a function, repeat will call it each repeated time\n * @param {number} times - number of times that element should be included/called for the resulting array. Anything less than or equal to 0, or not a number, will return an empty array.\n * @function\n * @param {boolean} cloneDeep - if true, it will deeply clone the element for every instance in the resulting array \n * @returns an array of repeated elements or results from the function call\n * @example repeat(1, 3) // returns [1, 1, 1]\n * @example repeat(() => 2 * 2, 3) // returns [4, 4, 4]\n */\nexport const repeat = (element, times, cloneDeep=false) => {\n  if (!times || times <= 0) return []\n  if (!isNum(times)) {\n    console.error(\"Times argument must be a number\")\n    return []\n  }\n  const arr = []\n  for (let i = 0; i < times; i++) {\n    const value = isFunc(element)\n      ? element() \n      : cloneDeep\n        ? deepClone(element)\n        : element\n    arr.push(value)\n  }\n  return arr\n}\n","/** @module object */\n\nimport { sanitize } from '../string/sanitize'\n\n/**\n * Sanitizes all html strings in an object's properties.\n * @function\n * @param {Object} obj to be sanitize\n * @return {Object} - obj with strings sanitized\n */\nexport const sanitizeCopy = obj => JSON.parse(sanitize(JSON.stringify(obj)))\n","/** @module collection */\n\nimport { get } from './get'\nimport { isArr } from '../array/isArr'\nimport { isNum } from '../number/isNum'\nimport { isStr } from '../string/isStr'\nimport { isColl } from './isColl'\n\n/**\n * Compares a collection's keys / values with another collections keys / values\n * @example\n * shallowEqual({ foo: 'bar' }, { foo: 'bar' })\n * // Returns true\n * @example\n * shallowEqual({ foo: 'bar', baz: {} }, { foo: 'bar', baz: {} })\n * // Returns false, because the baz values are different objects\n * @example\n * // Works with array too\n * shallowEqual([ 1, 2 ], [ 1, 2 ])\n * // Returns true\n * @example\n * shallowEqual([{ foo: 'bar' }], [{ foo: 'bar' }])\n * // Returns false, because the objects in index 0 are different\n * @example\n * // Pass a path to compare instead of the root\n * shallowEqual({ foo: { bar: { baz: 'biz' }}}, { foo: { bar: { baz: 'biz' }}}, 'foo.bar')\n * // Returns true, because the bar object is compared\n * @function\n * @param {Object|Array} col1 - Collection to compare\n * @param {Object|Array} col2 - Collection to compare\n * @param {Array|string} path - path of object to compare. Uses the get method to find the path\n *\n * @returns {boolean} - true or false if the objects keys values are equal\n */\nexport const shallowEqual = (col1, col2, path) => {\n\n  // If a path is passed in, update the collections to be that path\n  if(path && (isArr(path) || isStr(path))){\n    col1 = get(col1, path)\n    col2 = get(col2, path)\n  }\n  \n  // If the objects are the same, so return true\n  if(col1 === col2) return true\n\n  // Ensure the objects exist, and they have keys we can compare\n  if (!col1 || !isColl(col1) || !col2 || !isColl(col2))\n    return false\n\n  // If they have different key lengths, then they are not equal\n  if (Object.keys(col1).length !== Object.keys(col2).length) return false\n  \n  // Loop the keys, and ensure the other collection has the key and it's value is the same\n  for (const key in col1)\n    if (col1[key] !== col2[key]) return false\n\n  // Keys and values are equal, so return true\n  return true\n}","/** @module string */\n\n/**\n * Remove an `s` at the end of a string, if the last char is an `s`,\n * @function\n * @param {string} str - string to convert\n * @return {string} string as singular\n */\nexport const singular = str => {\n  if (!str || !str.length) return str\n  return str[str.length - 1] === 's'\n    ? str.slice(0, str.length - 1)\n    : str\n}\n\n","/** @module string */\n\nimport { delimitString } from './delimitString'\n\n/**\n * Converts a string to snake_case.\n * @function\n * @param {string} str to be converted\n * @example\n *  snakeCase('fooBar') // returns 'foo_bar'\n * @returns the string in snake_case, or the input if it is not a string\n */\nexport const snakeCase = (str) => {\n  const underscored = delimitString(str, '_')\n  return underscored.toLowerCase()\n}\n","/** @module object */\n\nimport { isFunc } from '../method/isFunc'\nimport { pipeline } from '../method/pipeline'\nimport { isObj } from './isObj'\n\n/**\n * Like \"some\" for arrays, but operates across each entry in obj\n * @function\n * @param {Object} obj \n * @param {Function} predicate of form (key, value) => boolean. Returns true or false for the entry\n * @returns boolean indicating that at least one entry satisfied the predicate or not\n */\nexport const someEntry = (obj, predicate) => {\n  if (!obj) {\n    console.error(`someEntry expects argument obj [${obj}] to be defined.`)\n    return false\n  }\n\n  if (!isObj(obj)) {\n    console.error(`Argument obj ${obj} must be an object.`)\n    return false\n  }\n\n  if (!isFunc(predicate)) {\n    console.error(`Argument 'predicate' passed into someEntry must a function. Found: ${predicate}`)\n    return false\n  }\n\n  return pipeline(\n    obj,\n    Object.entries,\n    entries => entries.some(([key, value]) => predicate(key, value))\n  )\n}","/** @module string */\n\nimport { isStr } from './isStr'\nimport { camelCase } from './camelCase'\n\n/**\n * Converts a string to css in js format.\n * Useful for converting css rules into js format, I.E. margin-top => marginTop.\n * @function\n * @param {string} str - string to be converted\n * @return {string} - string in style case format\n */\nexport const styleCase = str => {\n  if(!isStr(str)) return str\n\n  const cased = camelCase(str)\n  return `${cased[0].toLowerCase()}${cased.slice(1)}`\n}\n","/** @module functions */\n\n/**\n * Throttle function calls to only execute once over a wait period\n * @example\n * throttle(() => console.log('throttled'), 50)()\n * @function\n * @param {*} func - method to call after wait\n * @param {number} [wait=100] time to wait between calls\n * @return {function} throttled function\n */\nexport const throttle = (func, wait = 100) => {\n  let waiting = false\n  return function(...args){\n    if (waiting) return\n    waiting = true\n    func.apply(this, args)\n    return setTimeout(() => {\n      waiting = false\n    }, wait)\n  }\n}\n","/** @module functions */\n\n/**\n * Ensures the last call to the throttled function get called.\n * <br> Will wait the allotted time, before calling the last call to it.\n * <br> The final call will not execute until no more calls are made,\n * <br> Accepts a callback to call each time the throttle called,\n * @example\n * throttleLast(() => {}, () => {})()\n * // throttle function\n * @function\n * @param {function} func - method to call after wait\n * @param {function} cb - method to call after throttle function is called\n * @param {number} [wait=100] time to wait until executing func param\n * @return {function} throttled function\n */\nexport const throttleLast = (func, cb, wait = 100) => {\n  let throttleTimeout\n  return function(...args) {\n    // If the throttle already exists clear it, and create it again\n    if (throttleTimeout) clearTimeout(throttleTimeout)\n    // Store a reference to the timeout\n    // Will wait the allotted time until calling the final call to it\n    throttleTimeout = setTimeout(() => {\n      func.apply(this, args)\n      clearTimeout(throttleTimeout)\n    }, wait)\n    typeof cb === 'function' && cb()\n  }\n}\n","/** @module number */\n\nimport { equalsNaN } from './equalsNaN'\nimport { isNum } from './isNum'\nimport { getNums } from './getNums'\n\n/**\n * Converts passed in value to a float.\n * @example\n * toFloat('1.34')\n * // Returns 1.34\n* @example\n * toFloat(NaN)\n * // Returns 0\n * @function\n * @param {*} val - value to convert\n * @return {number} value converted to an float\n */\nexport const toFloat = val => (\n  val &&\n    !equalsNaN(val) &&\n    parseFloat( isNum(val) && val || getNums(val) ) ||\n    0\n)\n","/** @module number */\n\nimport { equalsNaN } from './equalsNaN'\nimport { isNum } from './isNum'\nimport { getNums } from './getNums'\n\n/**\n * Converts passed in value to an integer.\n * @example\n * toInt('1')\n * // Returns 1\n * @example\n * toInt(NaN)\n * // Returns 0\n * @function\n * @param {*} val - value to convert\n * @return {number} value converted to a integer\n */\nexport const toInt = val => (\n  val &&\n    !equalsNaN(val) && \n    parseInt( isNum(val) && val || getNums(val) ) ||\n    0\n)\n","/** @module object */\n\nimport { isStr } from '../string/isStr'\nimport { isArr } from '../array/isArr'\nimport { strToType } from '../ext/strToType'\n\n/**\n * Converts an array or string into an object.\n * @function\n * @param { array | string } val - to be converted to object\n * @param {string} divider - if string, what divides key from value\n * @param {string} split - if string, what splits each key/value pair\n * @return {Object} - converted object \n */\nexport const toObj = (val, divider, split) => {\n  if(isArr(val))\n    return Object.keys(val)\n      .reduce((obj, key) => {\n        obj[key] = val[key]\n\n        return obj\n      }, {})\n\n  if(!isStr(str)) return {}\n\n  divider = divider || '='\n  split = split || '&'\n  return str\n    .split(split)\n    .reduce((obj, item) => {\n      const sep = item.split(divider)\n      obj[sep[0].trim()] = strToType(sep[1].trim())\n\n      return obj\n    }, {})\n}\n","/** @module string */\n\nimport { isStr } from './isStr'\n\n/**\n * Converts a string to train case, I.E. marginTop => margin-top.\n * @function\n * @param {string} string to be converted\n * @return {string} - string in train case format\n */\nexport const trainCase = str => (\n  isStr(str) && str\n    .split(/(?=[A-Z])|[\\s_-]/gm)\n    .join('-')\n    .toLowerCase() || str\n)\n","/** @module object */\n\nimport { isStr } from '../string/isStr'\n\n/**\n * Trims objects string fields.\n * @function\n * @param {Object} object\n * @return {Object} - object with string fields trimmed\n */\nexport const trimStringFields = object => (\n  Object\n    .entries(object)\n    .reduce((cleaned, [ key, value ]) => {\n      cleaned[key] = isStr(value) ? value.trim() : value\n      return cleaned\n    }, object)\n)\n","/** @module collection */\n\nimport { updateColl } from './updateColl'\n\n/**\n * Removes a path from an object.\n * @example\n * unset(obj, 'foo.bar')\n * // Returns the passed in obj, with the value of bar set to undefined\n * @function\n * @param {Object} obj - object to have the attribute removed\n * @param {string|array} path - path of attribute to be removed, separated by string\n * @return the passed in object, with the attribute found at the path removed\n */\nexport const unset = (obj, path) => updateColl(obj, path, 'unset')\n","/** @module promise */\n\n'use strict'\n\nimport { isObj } from '../object/isObj'\nimport { isFunc } from '../method/isFunc'\n\n/**\n * Stops execution for a given amount of time\n * @function\n * @param {number} time - Amount of time to wait\n * @return { void }\n */\nexport const wait = time => (new Promise((res, rej) => setTimeout(() => res(true), time)))","/** @module string */\n\nimport { isStr } from './isStr'\nimport { cleanStr } from './cleanStr'\nimport { capitalize } from './capitalize'\n\n/**\n * Converts all words in a string to be capitalized.\n * @function\n * @param {string} string to be converted\n * @return {string} - string with all words capitalized\n */\nexport const wordCaps = str => {\n  if (!isStr(str)) return str\n  let cleaned = cleanStr(str)\n  return cleaned\n    .split(' ')\n    .map(word => word && capitalize(word) || '')\n    .join(' ')\n}\n"],"names":["OPTIONS","SHOULD_LOG","SHOULD_THROW","LOG_PREFIX","validate","argObj","validators","logs","throws","prefix","validationCaseEntries","Object","entries","defaultValidator","validationResults","map","argName","argValue","validateArgument","success","cases","reduce","total","next","validationReducer","setOptions","undefined","resetOptions","key","value","validator","validatorString","name","toString","reason","finalResult","nextValidation","handleFailure","validation","shouldLog","shouldThrow","Error","join","console","error","isArr","Array","isArray","buildElementCountMap","arr","counts","Map","i","length","element","count","get","set","areCountMapsEqual","mapA","mapB","size","isObj","obj","isFunc","func","applyToFunc","item","expression","args","pipeline","functions","result","fn","isStr","str","mapString","charMapper","char","isLowerCase","toLowerCase","isUpperCase","toUpperCase","delimitString","delimiter","delimiters","isDelimiter","c","some","del","prevChar","capitalize","lowercaseTail","tail","slice","removeDot","string","noDot","indexOf","cleanStr","replace","camelCase","compCase","split","cased","word","index","toStr","val","JSON","stringify","sanitize","isColl","updateColl","path","type","org","parts","from","pop","prop","breakPath","shift","fallback","template","tempStr","data","regex","match","exact","substr","trim","replaceWith","isBool","isStrBool","convertToStrBool","softFalsy","Boolean","toBool","equalsNaN","isNum","isNonNegative","getNums","toNum","Number","isOrderable","x","compareTo","y","valid","$default","localeCompare","identity","hasOwn","prototype","hasOwnProperty","call","uuid","a","Math","random","cloneFunc","funcClone","apply","defineProperty","configurable","typeOf","matchArg","entry","caseValueOrPredicate","valueOnMatch","default","deepFreeze","freeze","getOwnPropertyNames","isFrozen","noOpObj","noPropObj","content","noPropArr","findExtrema","comparator","extremaSoFar","uniqArrByReference","filter","e","cleanColl","coll","recursive","keys","cleaned","keyList","hasProp","deepEqual","b","arrA","arrB","dateA","Date","dateB","getTime","regexpA","RegExp","regexpB","deepClone","hash","WeakMap","Set","has","source","flags","constructor","create","cloneObjWithPrototypeAndProperties","assign","objectWithPrototype","getPrototypeOf","sourceDescriptors","getOwnPropertyDescriptors","descriptor","clone","isSealed","seal","strToType","parse","SHOW_LOGS","METH_DEF","PREFIX","LOG_TYPES","logData","clearObj","deepMerge","sources","merged","srcCopy","joined","isEntry","maybeEntry","mapEntries","cb","initialValue","reduceObj","start","promisify","method","Promise","res","rej","push","cbData","defObjProps","concat","functionName","addAsync","object","__IS_PROMISIFIED__","getValue","getOwnPropertyDescriptor","queryToObj","currentQueryItems","stringSplit","querystring","components","itemSplit","array","decodeURIComponent","mutatorCb","warn","otherArr","arrCounts","otherCounts","longest","shortest","arrSet","arg","camelCasedSplit","idx","params","message","predicate","substring","fromIndex","wait","immediate","timeout","context","this","callNow","clearTimeout","setTimeout","num","bindTo","doItAmount","responses","val1","val2","check","func1","func2","obj1","obj2","str1","str2","every","propSelector","mapFn","inputIsValid","finalArr","current","el","paramKey","doc","document","search","location","_doc$location","_queryToObj","values","test","date","isNaN","one","two","use","promise","then","catch","err","keyMapper","getCacheKey","limit","memorized","cache","arguments","destroy","mod","firstSet","urlStr","useVal","encodeURIComponent","_","updated","startIndex","nextArr","splice","proto","amount","useAmount","randoms","floor","sort","times","cloneDeep","log","methDef","col1","col2","waiting","throttleTimeout","parseFloat","parseInt","divider","sep","selector","unique","id","add","time"],"mappings":"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"}